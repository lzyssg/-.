# 算法基础

```c++
/*

\\ \\ \\ \\ \\ \\ \\ \\ || || || || || || // // // // // // // //
\\ \\ \\ \\ \\ \\ \\        _ooOoo_          // // // // // // //
\\ \\ \\ \\ \\ \\          o8888888o            // // // // // //
\\ \\ \\ \\ \\             88" . "88               // // // // //
\\ \\ \\ \\                (| -_- |)                  // // // //
\\ \\ \\                   O\  =  /O                     // // //
\\ \\                   ____/`---'\____                     // //
\\                    .'  \\|     |//  `.                      //
==                   /  \\|||  :  |||//  \                     ==
==                  /  _||||| -:- |||||-  \                    ==
==                  |   | \\\  -  /// |   |                    ==
==                  | \_|  ''\---/''  |   |                    ==
==                  \  .-\__  `-`  ___/-. /                    ==
==                ___`. .'  /--.--\  `. . ___                  ==
==              ."" '<  `.___\_<|>_/___.'  >'"".               ==
==            | | :  `- \`.;`\ _ /`;.`/ - ` : | |              \\
//            \  \ `-.   \_ __\ /__ _/   .-` /  /              \\
//      ========`-.____`-.___\_____/___.-`____.-'========      \\
//                           `=---='                           \\
// //   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  \\ \\
// // //      佛祖保佑      永无BUG      永不修改        \\ \\ \\
// // // // // // || || || || || || || || || || \\ \\ \\ \\ \\ \\

*/

一个算法看不懂的原因主要是人的工作记忆是有限的，只能处理有限块的信息。当一个算法的思路呈现在我们面前的时候它对于我们是无序的，可能会被分成十几块甚至几十块来理解，那样的话我们处理了后面就无法顾及前面，所以不能形成贯通的思路，直观体验就是“没懂”。而为什么最后能看懂呢？因为在一遍遍看的过程中它的某些部分已经连接了起来，几小块连成了一块，顺序也逐渐清晰，最后会合成 一大块，也就是最后懂了。所以不要灰心，努力理解的话它最终是会有条理的，到那时候再看就来龙去脉都十分清楚了。
```



## 基础算法

### 快速排序

[^以j为划分时，x不能取q[r\]作中枢，（以i为划分时，x不能取q[l\]作中枢]: ）

![image-20220903235603721](C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20220903235603721.png)

![image-20220904000015056](C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20220904000015056.png)

```c++
void quick_sort(int q[],int l,int r){
	if(l>=r) return;
    int i=l-1,j=r+1,x=q[l+r>>1];//x=q[l]
	while(i<j){
	do i++;while(q[i]<x);
	do j--;while(q[i]>x);
	if(i<j) swap(q[i],q[j]);//双指针遍历 x左全为小，右全大 如果i＜j则需要掉换值
	}
	quick_sort(q,l,j),quick_sort(q,j+1,r);

```

***

```c++
void quick_sort(int q[],int l,int r){
	if(l>=r) return;
    int i=l-1,j=r+1,x=q[l+r+1>>1];//x=q[r]
	while(i<j){//此处不能取等 4 5 取相等会内存负溢出
	do i++;while(q[i]<x);
	do j--;while(q[i]>x);
	if(i<j) swap(q[i],q[j]);
	}
	quick_sort(q,l,i-1),quick_sort(q,i,r);
```

边界情况分析
分析

快排属于分治算法，最怕的就是 n分成0和n，或 n分成n和0,这会造成无限划分

1.以j为划分时，x不能选q[r] (若以i为划分,则x不能选q[l])

假设 x = q[r]

关键句子quick_sort(q, l, j), quick_sort(q, j + 1, r);

由于j的最小值是l,所以q[j+1..r]不会造成无限划分

但q[l..j](即quick_sort(q, l, j))却可能造成无限划分，因为j可能为r

举例来说，若x选为q[r]，数组中q[l..r-1] < x,

那么这一轮循环结束时i = r, j = r，显然会造成无限划分

2.

do i++; while(q[i] < x)和do j--; while(q[j] > x)不能用q[i] <= x 和 q[j] >= x

假设q[l..r]全相等

则执行完do i++; while(q[i] <= x);之后，i会自增到r+1

然后继续执行q[i] <= x 判断条件，造成**数组下标越界**

并且如果之后的q[i] <= x (此时i > r) 条件也不幸成立，

就会造成一直循环下去(亲身实验)，造成内存超限(Memory Limit Exceeded)

3.

if(i < j) swap(q[i], q[j])能否使用 i <= j

可以使用if(i <= j) swap(q[i], q[j]);

因为 i = j 时，交换一下q[i],q[j] 无影响，因为马上就会跳出循环了

4.

最后一句能否改用quick_sort(q, l, j-1), quick_sort(q, j, r)作为划分(用i做划分时也是同样的道理,)

不能

根据之前的证明，**最后一轮循环**可以得到这些结论

**j <= i 和 q[l..i-1] <= x, q[i] >= x 和 q[j+1..r] >= x, q[j] <= x**

所以，q[l..j-1] <= x 是显然成立的，

**但quick_sort(q, j, r)中的q[j] 却是 q[j] <= x，这不符合快排的要求**

另外一点，注意quick_sort(q, l, j-1), quick_sort(q, j, r)可能会造成无线划分

当x选为q[l]时会造成无限划分，报错为(MLE),

如果手动改为 x = q[r],可以避免无限划分

但是上面所说的q[j] <= x 的问题依然不能解决，这会造成 WA (Wrong Answer)

5.

j的取值范围为[l..r-1]

证明:

假设 j 最终的值为 r ,说明只有一轮循环(两轮的话 j 至少会自减两次)

说明q[r] <= x (因为要跳出do-while循环)

说明 i >= r(while循环的结束条件), i 为 r 或 r + 1(必不可能成立)

说明 i 自增到了 r , 说明 q[r] >= x 和 q[l..r-1] < x,

得出 q[r] = x 和 q[l..r-1] < x 的结论,但这与 x = q[l + r >> 1]矛盾

反证法得出 j < r

假设 j 可能小于 l 说明 q[l..r] > x ,矛盾

反证法得出 j >= l

所以 j的取值范围为[l..r-1],不会造成无限划分和数组越界



### 归并排序

```c++
void merge_sort(int q[],int l,int r){
	if(l>=r) return;
	int mid=l+r>>1;
	merge_sort(q,l,mid);
	merge_sort(q,mid+1,r);
	
	int k=0,i=l,j=mid+1;
	while(i<=mid && j<=r){
		if(q[i]<=q[j]) tmp[k++]=q[i++];
		else tmp[k++]=q[j++];
	}
	while(i<=mid) tmp[k++]=q[i++];
	while(j<=r) tmp[k++]=q[j++];
	for(i=l,j=0;i<=r;i++,j++) q[i]=tmp[j];
}
```

#### eg：逆序对数量问题

- 给定一个长度为 nn 的整数数列，请你计算数列中的逆序对的数量。

  逆序对的定义如下：对于数列的第 ii 个和第 jj 个元素，如果满足 i<ji<j 且 a[i]>a[j]a[i]>a[j]，则其为一个逆序对；否则不是。

```c++
#include<bits/stdc++.h>
using namespace std;
const int  N=100010;
typedef long long ll;
int a[N],tmp[N];
ll merge_sort(int q[],int l,int r){
    if(l>=r) return 0;
    int mid=l+r>>1;
    ll res=merge_sort(q,l,mid)+merge_sort(q,mid+1,r);
    int k=0,i=l,j=mid+1;
    while(i<=mid && j<=r){
        if(q[i]<=q[j]) tmp[k++]=q[i++];//必须带=,题目要求逆序对是＞
        else{
            tmp[k++]=q[j++];
            res+=mid-i+1;//mid是左半段右边界，mid-i+1求出一共有多少元素逆序
        }
    }
    while(i<=mid) tmp[k++]=q[i++];
    while(j<=r) tmp[k++]=q[j++];
    for(i=l,j=0;i<=r;i++,j++) q[i]=tmp[j];
    return res;
}
int main()
{
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d", &a[i]);

    cout << merge_sort(a, 0, n - 1) << endl;

    return 0;
}

```

1. 归并排序先拆分成两半排序后再合并，逆序对数量要求有多少个大小顺序颠倒的。与归并排序不谋而合
2. 在每一层合并中顺便求出逆序对数量，通过分治递归来将总的逆序对数量累加出来。

题解：merge_sort(q,l,mid)和merge_sort(q,mid+1,r);我们把它看成两段已经排序好的子序列，第一段区间（l，mid）第二段（mid+1，r），通过两个指针分别扫过这两个区间，如果第一段发现i处大于第二段j处，那么从i开始到mid的元素都大于j，共有mid-i+1个元素。，所以只需要在j>i的时候累加前面返回的元素和就可以了。tmp数组注意要是全局定义。

### 二分

#### 整数二分

- 整数二分由于取整，需要根据题目条件来进行边界处理

```c++
bool check(int x){//}//检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l,int r){
	while(l<r){//当l=r时候退出循环
		int mid=l+r>>1;
		if(check(mid)) r=mid;
		else l=mid+1;
	}
	return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l,int r){
	while(l<r){
		int mid=l+r+1>>1;//如果不加一 l=r-1>>1则下面l=l会死循环
		if(check(mid)) l=mid;
		else r=mid-1;
	}
	return l;
}
```

![image-20220905235846075](C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20220905235846075.png)

- 红色右边端点是满足这个条件的最大值，绿色左边端点是满足右边条件的最小值。
- **整数二分的思想是求红色范围的右边端点或者绿色范围的左边端点**
- 举个例子 12234 要找出2出现的第二次的下标，则要用第2条公式筛选出红右。 如果要找出2出现的第一次的下标，则用第1条公式找出绿左。

#### 浮点数二分

```c++
bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

- 一般情况，两个数差小于1e-6，则两个数相同。例如1.0000001和1.0000002相等 

- 浮点数二分可用来求立方差

  ### 高精度加法

  ```c++
  vector<int> add(vector<int> &A,vector<int> &B){
  	if(A.size()<B.size()) return add(B,A);
  	vector<int> C;
  	int t=0;
  	for(int i=0;i<A.size();i++){
  		t+=A[i];
  		if(i<B.size()) t+=B[i];
  		C.push_back(t%10);
  		t/=10;
  	}
  	if(t) C.push_back(t);
  	return C;
  }
  ```

### 	高精度减法

```c++
vector<int> sub(vector<int> &A,vector<int> &B){
	vector<int> C;
	int t=0;
	for(int i=0;i<A.size();i++){
		t=A[i]-t;
		if(i<B.size()) t-=B[i];
		C.push_back((t+10)%10);
		if(t<0) t=1;
		else t=0;
	}
	while(C.size()>1 && C.back()==0) C.pop_back();//back函数取出容器里最后一个数，pop去除前置0
	return C;
}
```

- 高精度加法和减法类似，加法中每个位相加，个位数余10保留，进位/10即可

- 减法中要注意的是可以用+10再余10的方式将差大于或小于0的情况合二为一，如果差t小于0，则下一位进位中要减1，反之不减

- while(c.size()>1 && c.back()==0) c.pop_back()去除前导0的情况

  ### 

  ## 高精度乘法
  
  ```c++
  vector<int> mul(vector<int> &A, int b){
  	vector<int> C;
  	int t=0;
  	for(int i=0;i<A.size() || t;i++){//带上t 最高位和b相乘可能是两位数需要压入容器
  		if(i<A.size()) t+=A[i]*b;
  		C.push_back(t%10);
  		t/=10;
  	}
  	while(C.size()>1 && C.back==0) C.pop_back();//去除前置0
  	return C;
  }
  ```

  ### 高精度除法
  
  ```c++
  vector<int> div(vector<int> &A,int b,int &r){//r是引用主函数定义的变量r，执行完此函数后主函数定义的r也有值了
  	vector<int> C;
      r=0;//第一步r=0
      for(int i=A.size()-1;i>=0;i--){//除法和加减乘相反，要从最高位开始算，A有几位则循环几次
      	r=r*10+A[i];
      	C.push_back(r/b);
      	r%=b;
      }
      reverse(C.begin(),C.end());//高位数先压入容器，因此需要反转
      while(C.size()>1 && C.back==0) C.pop_back();
      return C;
  }
  ```
  
  - 除法和加减乘法区别在于，除法求余数从最高位开始，加减乘从最低位开始。因此除法运算中高位会被先压入栈，低位后压入。所以需要reverse反转栈。
  
    ### 一维前缀和
  
    ```c++
    S[i] = a[1] + a[2] + ... a[i]//a从1开始，如果从0开始，sr-s-1不对，需要额外判断
    a[l] + ... + a[r] = S[r] - S[l - 1]
    ```
  
    ### 二维前缀和
  
    ![image-20220907105356528](C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20220907105356528.png)

```c++
S[i, j] = 第i行j列格子左上部分所有元素的和
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[i,j]=s[i-1][j]+S[i][j-1]-S[i-1][j-1]+a[i][j]
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]

```

- d第一步要先初始化二维前缀和数组，先初始化每个坐标的值，再用sij的公式去初始化前缀和数组的值

- 第二步求任意面积的前缀和（不从11处开始），可以用第一步初始完的前缀和数组代入第二条公式

  ### 差分

  - 输入一个长度为 n 的整数序列。

    接下来输入 m 个操作，每个操作包含三个整数 l,r,c，表示将序列中 [l,r] 之间的每个数加上 c。

    请你输出进行完所有操作后的序列。

    **给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c**

    ```c++
    #include <iostream>
    
    using namespace std;
    
    const int N = 100010;
    
    int n, m;
    int a[N], b[N];
    
    void insert(int l,int r,int c){
        b[l]+=c;
        b[r+1]-=c;
    }
    
    int main(){
        scanf("%d%d",&n,&m);
        for(int i=1;i<=n;i++) scanf("%d",&a[i]);
                                           //这里insert可以换成b[i]=a[i]+a[i-1]; 目的是为了构造b的前缀和数组
    for(int i=1;i<=n;i++) insert(i,i,a[i]);//把a[i]和b[i]初始看成0,bi就是ai的差分,现在往每个a[i]插入一个数,b仍是a的差分数组
        while(m--){
            int l,r,c;
            cin>>l>>r>>c;
            insert(l,r,c);
        }
         for(int i=1;i<=n;i++) b[i]+=b[i-1];//把差分数组换为前缀和数组
            for(int i=1;i<=n;i++) cout<<b[i]<<' ';
        return 0;
    }
    ```

    - 一维差分常见题型有往区间l,r中加数,如果用暴力求解复杂度为o(n).

    - 用差分的方法把原始数组看成前缀和数组,第一步先构造原数组的差分数组,原数组l到都r+1实际等于差分数组l位1,到r+1位再-1.复杂度为o(1)

    - **insert(i,i,a[i])解释!!**构造差分数组,可以把原数组全部看成0,差分数组未初始化也为0.此时他们满足前缀和和差分的关系.但由于原数组并不是0,我们可以看作原数组在(i,i)的位置插入了它的值,这就相当于在原数组的差分数组中,从i的起始位置加了数,再i+1的位置把这个数减去.这时候a[i]仍然是b[i]的差分数组,构造完毕

    - 最后得到的b数组是虚拟出来的差分数组,要换成原数组输出

      ### 差分矩阵

      - 输入一个 nn 行 mm 列的整数矩阵，再输入 qq 个操作，每个操作包含五个整数 x1,y1,x2,y2,cx1,y1,x2,y2,c，其中 (x1,y1)(x1,y1) 和 (x2,y2)(x2,y2) 表示一个子矩阵的左上角坐标和右下角坐标。

        每个操作都要将选中的子矩阵中的每个元素的值加上 cc。

        请你将进行完所有操作后的矩阵输出。

        ![image-20220907191840773](C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20220907191840773.png)

        ```c++
        #include<bits/stdc++.h>
        using namespace std;
        const int N=1010;
        int a[N][N],b[N][N];
        void insert(int x1,int y1,int x2,int y2,int c){
            b[x1][y1]+=c;
            b[x1][y2+1]-=c;
            b[x2+1][y1]-=c;
            b[x2+1][y2+1]+=c;
        }
        int main(){
            int n,m,q;
            scanf("%d%d%d",&n,&m,&q);
            for(int i=1;i<=n;i++){
                for(int j=1;j<=m;j++){
                    scanf("%d",&a[i][j]);
                }
            }
            
            //构造差分矩阵
            for(int i=1;i<=n;i++){
                for(int j=1;j<=m;j++){
                    insert(i,j,i,j,a[i][j]);//带入insert可以求出差分数组 或者直接a[i][j] = s[i][j] - s[i - 1][j] - s[i][j - 1] + s[i - 1][j - 1];
                }
            }
            
            while(q--){
                int x1,x2,y1,y2,c;
                cin>>x1>>y1>>x2>>y2>>c;
                insert(x1,y1,x2,y2,c);
            }
            
            //差分矩阵变为前缀和
            for(int i=1;i<=n;i++){
                for(int j=1;j<=m;j++){
                    b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];//这里应该是a[i][j]=a[i-1][j]+a[i][j-1]-a[i-1][j-1]+b[i][j];
              }
            }
            for(int i=1;i<=n;i++){
                for(int j=1;j<=m;j++){
                    cout<<b[i][j]<<" ";//或者输出a;
              }
              puts("");
            }
            return 0;
        }
        ```

        - 差分矩阵和一维差分类似,不同点在于差分矩阵有xy两个方向,要去除重复加过的地方
        - 原矩阵转换为差分矩阵,a[i][j]+c <=> b(i,j)可以把原矩阵看成坍塌的点,即在b(i,j)插入了a(i,j)的值.假设原矩阵a为0,差分矩阵b必然为0.但事实是原矩阵不为0,那么通过取出原矩阵任意顶点,可以把差分矩阵当成1x1的小方格,将原矩阵aij的值赋给bij,则a仍然是b的前缀和(**a数组的值变了，变成了a[i][j],这时如果b数组要想成为a数组的差分数组，值也要变为a[i][j],所以我们把b[i][j]变为a[i][j]**)

### 双指针算法

```c++
for (int i = 0, j = 0; i < n; i ++ )
{
    while (j < i && check(i, j)) j ++ ;
//这里的时间复杂度是O(n)
    // 具体问题的逻辑
}
常见问题分类：
    (1) 对于一个序列，用两个指针维护一段区间
    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作
```

\799. 最长连续不重复子序列

给定一个长度为 nn 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=100010;
int a[N],s[N];
int main(){
    int n;
    scanf("%d",&n);
    for(int i=0;i<n;i++) scanf("%d",&a[i]);
    
    int res=0;
    for(int i=0,j=0;i<n;i++){
        s[a[i]]++;
        while(s[a[i]]>1){//扫到重复数，i指针停下，j从0开始遍历，往右移动一次就剔除一个数字，直到剔除先前i重复数字，i继续移动
            s[a[j]]--;
            j++;
        }
        res=max(res,i-j+1);
    }
    printf("%d",res);
    return 0;
}
```

![image-20220909084551996](C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20220909084551996.png)

- 这题使用了双指针的算法，i和j各自只遍历了一遍，利用for while循环，巧妙的把朴素做法中for for循环的时间复杂度降低，在while中，我们通过编写的条件将j的值不停移动，剔除掉与结果无关的数字。

  ### 位运算之二进制中1的个数

  ```c++
  #include<iostream>
  using namespace std;
  int lowbit(int x){//lowbit就是找到二进制中最后一个1，比如10二进制带上符号位01010，lowbit：10110，相与只剩最后一个1存在，即00010.
      return x&-x;//-x相当于是x取反加1(~x+1),
  }
  int main(){
      int n;
      scanf("%d",&n);
      while(n--){
          int x;
          cin>>x;
          int res=0;
          while(x){
               x-=lowbit(x);//x每次把末位的1减去，当x等于0退出循环，减掉1的次数就是二进制中
              res++;
          }
          cout<<res<<' ';
      }
      return 0;
  }
  ```

  ### 离散化

  - 离散化模板

  ```c++
  vector<int> alls;//存储所有等待离散化的值
  sort(alls.begin(),alls.end());//将所有的值排序，注意带上头文件<algorithm>
  alls.erase(unique(alls.begin(),alls.end()),alls.end());//unique是把重复的放在后面，然后把下标返回到重复前的元素。erase是把重复前元素下标到原来容器下标之间的元素去除，从而达到去除重复元素的作用。
  
  //二分求出对应离散化的值，（离散化容器下标10000，但容器只有三个元素，它映射便小于等于e）
  int find(int x){
  	int l=0,r=alls.size()-1;
  	while(l<r){
  		int mid=l+r>>1;
  		if(alls[mid]>=x) r=mid;
  		else l=mid+1;
  	}
  	return r+1;//映射到1、2、。。。n 如果不带上+1，那么返回就是0 1 2（这是为了后面在做前缀和的预处理）
  }
  ```

  

  - eg 802区间和

    假定有一个无限长的数轴，数轴上每个坐标上的数都是 00。

    现在，我们首先进行 nn 次操作，每次操作将某一位置 xx 上的数加 cc。

    接下来，进行 mm 次询问，每个询问包含两个整数 ll 和 rr，你需要求出在区间 [l,r][l,r] 之间的所有数的和。

  ```c++
  #include<iostream>
  #include<algorithm>
  #include<vector>
  using namespace std;
  const int N= 3e5+10;//为什么开三十万，虽然区间可以达到10e9，但是我们插入的坐标实际只有n、l、r 也就是n+2m 三十万避免re加10即可
  typedef pair<int,int> PII;
  int a[N],s[N];
  int n,m;
  vector<int> alls;
  vector<PII> add,query;
  
  //用二分法来将alls数组中用不到的下标去除
  int find(int x){
      int l=0,r=alls.size()-1;
      while(l<r){
          int mid=l+r>>1;
          if(alls[mid]>=x) r=mid;
          else l=mid+1;
      }
      return r+1;
  }
  
  int main(){
      cin>>n>>m;
      for(int i=0;i<n;i++){
          int x,c;
          cin>>x>>c;
          add.push_back({x,c});//add数组存入了alls里的下标和对应的值
          alls.push_back(x);
      }
      
      for(int i=0;i<m;i++){
          int l,r;
          cin>>l>>r;
          query.push_back({l,r});//存入要查找l-r区间
          alls.push_back(l);//把要查找的区间压入alls数组，后面再去重
          alls.push_back(r);
      }
      
      //去重
      
      sort(alls.begin(),alls.end());
      alls.erase(unique(alls.begin(),alls.end()),alls.end());
      
      //处理插入 把alls过于离散的数值放入新开的数组中
      for(auto item : add){
          int x=find(item.first);
          a[x]+=item.second;
      }
      
      //构造前缀和数组 后面用于求取l-r区间的值
      for(int i=1;i<=alls.size();i++) s[i]=s[i-1]+a[i];
      
      //查询前缀和数组差
      
      for(auto item : query){
          int l=find(item.first),r=find(item.second);
          cout<<s[r]-s[l-1]<<endl;
      }
      return 0;
  }
  ```

  - 区间和问题可以用前缀和来处理，但是当下标过于大时候，我们要在前缀和运算前先做预处理，主要是以下几个思路
  - 第一步可以开一个alls容器来存储离散化前的值，用add容器来存入下标和插入的值，query来存入搜索区间内的值，再把搜索区间的下标压入alls容器中，这时候容器会出现重复的下标，我们需要去重处理
  - 第二步要把alls中离散开的值放入新的容器a中，使其连续。
  - 第三步就可以构造前缀和数组，将前缀和的值放入数组s中，s是a的前缀和
  - 最后用s[r]-s[l-1]公式就可以算出l到r之间的值  **主要难点还是在于离散**

### 区间合并

```c++
//将所有存在交集的区间合并
void merge(vector<pair<int,int>> &segs){
	vector<PII> res;
	int st=-2e9,ed=-2e9;//在区间左端开辟一个
	for(auto seg : segs){
		if(st<seg.first){
			if(st!=-2e9) res.push_back({st,ed});
			st=seg.first,ed=seg.second; 
		}
		else ed=max(ed,seg.second);
	}
	if(st!=-2e9) res.push_back({st,ed});//特判，因为上面满足if条件才加入res，最后一段区间的下一段不存在，如果不加则会少一个。
	seg=res;
}
```



- eg:

- 给定 nn 个区间 [li,ri][li,ri]，要求合并所有有交集的区间。

  注意如果在端点处相交，也算有交集。

  输出合并完成后的区间个数。

  例如：[1,3][1,3] 和 [2,6][2,6] 可以合并为一个区间 [1,6][1,6]。

  ```c++
  #include<iostream>
  #include<vector>
  #include<algorithm>
  using namespace std;
  typedef pair<int,int> PII;
  
  void merge(vector<pair<int,int>> &segs){//segs是在主函数定义的，需要引用这个变量
      vector<PII> res;
      int st=-2e9,ed=-2e9;//开一段负无穷区间，判断无意义情况
      sort(segs.begin(),segs.end());//排序不能忘，从左往右遍历合并区间是有序性的
      for (auto seg : segs)
          if (ed < seg.first)
          {
              if (st != -2e9) res.push_back({st, ed});//不是负无穷，那就加入res里
              st = seg.first, ed = seg.second;//是负无穷区间，没有意义，维护下一段区间
          }
          else ed = max(ed, seg.second);//下一段区间和维护的区间有交集，取右边界最大的合并
  
      if(st!=-2e9) res.push_back({st,ed});//特判，因为上面满足if条件才加入res，最后一段区间的下一段不存在，如果不加则会少一个
      segs=res;//把合并好的区间重新赋给原容器
  }
  
  int main(){
      int n;
      cin>>n;
      vector<PII> segs;
      while(n--){
          int l,r;
          cin>>l>>r;
          segs.push_back({l,r});
      }
      merge(segs);
      cout<<segs.size();
      return 0;
  }
  ```

  - 第一步先开一个区间小于最左区间的值，用来作空集判断，如果传来的值无意义则不理
  
  - 然后对整个区间进行排序，从左到右依次维护各个区间
  
  - 最后一个区间的下一段是空的，所以要加一条判断，否则最后一段区间不会被加进res，结果会少1
  
    
  
    
  
    ## 数据结构
    
    ### 单链表
    
    ```c++
    //head存储表头，指向下一个元素下标
    //e[]存储节点的值
    //ne[]存储当前节点的下一个节点的下标
    //idx表示用了多少个节点
    int head,e[],ne[],idx;
    
    //初始化
    void init(){
    	head=-1;
    	idx=0;//未进行操作时，idx为0.idx扮演两个角色，1是在一开始作为元素下标，方便我门查找2是每次操作 idx作为一个临时的辅助要操作的数的下标，每次插入操作都给新来的数一个家，然后idx下标增加，准备下一次的操作。
    }
    
    //在单链表头插入一个数
    void insert(int a){
    	e[idx]=a;
    	ne[idx]=head;
    	head=idx;
    	idx++;
    }
    
    //删除头节点
    void remove(){
    	head=ne[head];//head是指向下一个下标，指向下一个下标=下个下标的下个下标
    }
    
    //k节点后插入一个数
    void add(int k,int x){
    	e[idx]=x;
    	ne[idx]=ne[k];
    	ne[k]=idx;//如果要在第六个节点插入数，函数参数应该是k-1，因为k是从0开始，第n个节点实际下标是n-1
    	idx++;
    }
    ```
    
    - 这是静态链表，和动态链表不同处在于这是用数组连接。当数据很大时候，动态单链表new的时间过长，而静态数组可以大大节省时间。
    
    ### 双链表
    
    ```c++
    //e[]表示节点的值,l[]表示节点的左指针，r[]表示节点的右指针,idx表示当前用到了哪个节点
    int e[N],l[N],r[N],idx;
    
    //初始化
    void init(){
    	l[1]=0;
    	r[0]=1;
    	idx=2;
    }
    
    //在节点a的右边插入了一个数x
    void insert(int a,int x){
    	e[idx]=x;
    	l[idx]=a,
    	r[idx]=r[x];
    	l[r[x]]=idx;//这个必须写在下面的前面，否则rx先被赋值就错了
    	r[x]=idx;
    	idx++;
    }
    
    //删除节点a
    void remove(int a){
    	l[r[a]]=l[a];
    	r[l[a]]=r[a];
    }
    
    //第k个数的下标实际上是k+1,eg 第一个插入的是已经是第三个节点了，下标为2
    //遍历输出可以用for(int i[r0];i!=1;i=r[i])只要节点不等于1，则继续遍历
    
    ```
    
    - 双链表同样用数组来构造，比指针动态链表快得多。0和1是哑节点，作为双链表的头尾
    
    - 在插入操作中，要先处理插入点的向左向右，再把原链表的两个方向加入。加入注意先后顺序，先加入右边再加入左边.
    
      ### 模拟栈
    
      ```c++
      // tt表示栈顶
      int stk[N], tt = 0;
      
      // 向栈顶插入一个数
      stk[ ++ tt] = x;
      
      // 从栈顶弹出一个数
      tt -- ;
      
      // 栈顶的值
      stk[tt];
      
      // 判断栈是否为空
      if (tt > 0)
      {
      
      }
      ```
    
      #### 表达式求值 **hard**
    
      题：例如，`-1+2`,`(2+2)*(-(1+1)+2)` 之类表达式，输出结果
    
      ```c++
      #include<iostream>
      #include<cstring>
      #include<algorithm>//isdigit()判断是不是0~9的数字
      #include<stack>
      #include<unordered_map>//key值对应的map，类似哈希表
      using namespace std;
      
      stack<int> num;//操作数栈
      stack<char> op;//操作符栈
      
      void eval(){//清算函数
          auto b=num.top();num.pop();//第二个压入的操作数
          auto a=num.top();num.pop();//左边的操作数
          auto c=op.top();op.pop();
          int x;
          if(c=='+') x=a+b;
          else if(c=='-') x=a-b;
          else if(c=='*') x=a*b;
          else x=a/b;
          num.push(x);//把算好的数重新压入操作数栈
      }
      
      int main(){
          unordered_map<char,int> pr{{'+',1},{'-',1},{'*',2},{'/',2}};//运算符的优先级
          string str;//把表达式用string读入
          cin>>str;
          
          for(int i=0;i<str.size();i++){
              auto c=str[i];//读出来的是操作符还是操作数下面判断
              if(isdigit(c)){//读出来的是操作数
                  int x=0,j=i;
                  while(j<str.size() && isdigit(str[j])){
                      x=x*10+str[j++]-'0';如果读出来不是个位数，最后需要把各个进位总和返回
                  }
                  i=j-1;//上面j++过，正确值应该是j-1，然后返回给i继续遍历
                  num.push(x);//把读好的操作数压入栈
              }else if(c=='('){//如果读出来的是(，直接压入符栈
                  op.push(c);
              }else if(c==')'){//读出来的是），需要从右往前把括号内的数清算
                   while(op.top()!='(') eval();//在读到（之前全部清算
                  op.pop();
              }else{//这里必须是多级运算符while，不能用if 因为如果是3+2*2 +5 用if只会执行2*2，只执行了一次。
                  while(op.size() && pr[op.top()]>=pr[c]) eval();//操作符栈存在并且栈顶运算符优先级大于读入的，先把栈内清算再添加新的运算符
                  op.push(c);
              }
          }
          while(op.size()) eval();//不读了以后，清算剩余操作符和操作数 这里不能用num作条件，数栈最后会变成一个不会成空栈
          cout<<num.top()<<endl;
          return 0;
      }
      ```
    
      - 思路是把数放入数栈，运算符放入字符栈。根据读入的字符和定义的条件，取出数和运算符做运算，数运算完压入数栈，运算符算完丢掉
      - 几个容易疏漏和写错的地方
        1. 读入操作数后，定义的x和j.j是用来替代i继续遍历的中间值，不写也行但是容易搞乱。x是用来存储要压入数栈的数，因为读入的数可能不是一位数.
        2. 读入操作符是）时，我们需要把整个括号内的数值清算。while是多级运算符，if只能执行一次。直到找到左括号为止，一直放入eval函数清算。
        3. 其他读入的加减乘除运算符，我们要根据操作符栈顶目前的字符和读入的字符做比较，那如果栈里没运算符或者读入的运算符优先级较高，就直接压入。如果有运算符并且假如是*遇到了+-，就先把栈里的数先清算，再把低级的运算符压入。
        4. 读完所有字符后，如果操作符栈里没有字符，说明加减乘除等其他运算已经完成了。可以直接输出结果。否则就把栈里的运算清算完再输出。

## 数据结构

### 模拟队列

```c++
//hh表示队头，tt表示队尾
int q[N],hh=0,tt=-1;

//向队尾插入一个数
q[++tt]=x;

//从队头弹出一个数 hh往右走 左边的被丢掉
hh++;

//队头的值
q[hh];

//判断队列是否为空
if(hh<=tt){
	
}

```

### 单调栈

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201211221031165.gif#pic_center)

```c++
常见模型：找到左边比他大或者小的数 （满足单调性）
int tt=0;
for(int i=1;i<=n;i++){//i是0是1根据情况而定
	while(tt && check(skn[tt],i)) tt--;
	skn[++tt]=i;
}
//满足单调性，如果发现(1:ax>ay 2:x<y)满足逆序的关系，可以把不满足小于i的元素踢出栈，再把i压入栈，构造出一个单调栈。此题型如果用暴力多重for循环时间复杂度过高，需优化。
```

### 滑动窗口 **hard**

```c++
模型：找出滑动窗口中的最大值和最小值
//如果长度为n，窗口长为k 那么暴力做法时间复杂度为O(nk),用单调队列将不可能满足条件的元素踹掉，节省了效率，时间复杂度为O(k)

int hh=0,tt=-1;//这里hh是队列头，tt是队尾。当hh<=tt时，说明队列有元素
for(int i=0;i<n;i++){
	while(hh<=tt && check_out(q[hh])) hh++;//如果队列不为空，且队列头没有滑出窗口（窗口长k） 这里的check判断队头的下标是否小于i-k+1,是说明滑出窗口
	while(hh<=tt && check(q[tt],i)) tt--;//判断队尾和新增元素的大小关系，把不符合条件的踢掉，留下的队列严格维护单调性。
	q[++tt]=i;//把新增的元素下标加入队列
}
```

eg:给定一个大小为 n≤106n≤106 的数组。有一个大小为 kk 的滑动窗口，它从数组的最左边移动到最右边。你只能在窗口中看到 kk 个数字。每次滑动窗口向右移动一个位置。以下是一个例子：该数组为 `[1 3 -1 -3 5 3 6 7]`，kk 为 33。

//错误代码

```c++
#include<iostream>
using namespace std;
int a[N],q[N];//a数组存值，q数组存下标

int main(){
    int n,k;
    scanf("%d%d",&n,&k);
    for(int i=0;i<n;i++) scanf("%d",&a[i]);
    
    int hh=0,tt=-1;
    for(int i=0;i<n;i++){
        if(hh<=tt && i-k+1>q[hh]) hh++;
        while(hh<=tt && a[q[tt]]>=a[i]) tt--;
        q[++tt]=i;
        if(q[hh]>=k-1) printf("%d",a[q[hh]]);//这里判断是否满足k，应该用i q[hh]不是从0开始的，会漏zhi
    }
    puts("");
    
    hh=0,tt=-1;
    for(int i=0;i<n;i++){
        if(hh<=tt && i-k+1>q[hh]) hh++;
        while(hh<=tt && a[q[tt]]<=a[i]) tt--;
        q[++tt]=i;
        if(q[hh]>k-1) printf("%d",a[q[hh]]);//这里判断是否满足k，应该用i q[hh]不是从0开始的，会漏zhi
    }
    puts("");
    return 0;
}
```

```c++
//正确代码
#include<iostream>
using namespace std;
const int N=1e6+10;
int a[N];//存值
int q[N];//存下标

int main(){
    int n,k;
    scanf("%d%d",&n,&k);
    for(int i=0;i<n;i++) scanf("%d",&a[i]);
    
    int hh=0,tt=-1;
    for(int i=0;i<n;i++){
        if(tt>=hh && i-k+1>q[hh]) hh++;//如果队列不为空，并有达到窗口值 队头移动到下一位
        while(tt>=hh && a[q[tt]]>=a[i]) tt--;//如果队列不为空，并且队尾大于新加入的值，把队尾舍去
        q[++tt]=i;
        if(i>=k-1) printf("%d ",a[q[hh]]);//i起始是0，当窗口满足三个时，k=2 此时开始输出单调队列的队头，也就是最小值
    }
    
    puts("");
    //求最大值
    
    hh=0,tt=-1;//非常关键 要把队头队尾重新初始化
    for(int i=0;i<n;i++){
        if(tt>=hh && i-k+1>q[hh]) hh++;
        while(tt>=hh && a[q[tt]]<=a[i]) tt--;
        q[++tt]=i;
        if(i>=k-1) printf("%d ",a[q[hh]]);
    }
    puts("");
    return 0;
}

```

### KMP字符串**hard2**

<img src="C:\Users\86153\Desktop\算法基础课\2231.jpg" style="zoom:50%;" />

```c++
//s[]是长串，p[]是待被匹配的串，n是s的长度，m是p的长度

//求模式串的next数组
for(int i=2,j=0;i<=m;i++){//ne[1]只有一个元素默认0,ne[0]没值是空
	while(j && p[i]!=p[j+1]) j=ne[j];//i从2开始，如果尾部不等于头部，j=ne[0]退回原点，(也就是说i和j要错开来类似双指针，i遍历，j满足条件后才继续遍历)
	if(p[i]==p[j+1]) j++;//如果尾部等于头部，j向右移动一次 下一次循环判断第二个和最后一个是否相同 例如a？a？ abab
	ne[i]=j;//j如果一直在原点，公共前缀数量为0.(j从0开始，每次遇到一个匹配的则前缀数加1)
}

//匹配字符串
for(int i=1,j=0;i<=n;i++){
	while(j && s[i]!=s[j+1]) j=ne[j];//匹配失败了，找j+1以前的字符串，让前面的公共前缀匹配后头的后缀
	if(s[i]==s[j+1]) j++;//匹配成功就接着下一个匹配
	if(j==n){
		j=ne[j];//abcabc 匹配完第一个abc继续移动到第二个a起点继续遍历
		//匹配成功后的逻辑
	}
}
```

eg:给定一个字符串 SS，以及一个模式串 PP，所有字符串中只包含大小写英文字母以及阿拉伯数字。

模式串 PP 在字符串 SS 中多次作为子串出现。

求出模式串 PP 在字符串 SS 中所有出现的位置的起始下标。

//错误代码

```c++
#include<iostream>
using namespace std;
const int N=1e5+10,M=1e6+10;
char p[N],s[M];
int ne[N];
int m,n;
int main(){
    cin>>n>>p+1>>m>>s+1;
    
    for(int i=2,j=0;i<=n;i++){
        while(j && p[i]!=p[j+1]) j=ne[j];
        if(p[i]==p[j+1]) j++;
        ne[i]=j;
    }
    
    //匹配
    
    for(int i=1,j=0;i<=m;i++){
        while(j && s[i]!=s[j+1]) j=ne[j];
        if(s[i]==s[j+1]) j++;//写成s[j+1]
        if(j==n){
            printf("%d ", i - n);
            j=ne[j];
        }
    }
    return 0;
}
```

```c++
//正确代码
#include<iostream>
using namespace std;
const int N = 100010, M = 1000010;

int n,m;
int ne[N];
char s[M],p[N];

int main(){
    cin>>n>>p+1>>m>>s+1;//数组下标从1开始
    
    //求next数组
    for(int i=2,j=0;i<=n;i++){//p[1]的next数组ne[1]默认为0
    while(j && p[i]!=p[j+1]) j=ne[j];//i从2开始，如果尾部不等于头部，j=ne[0]退回原点，(也就是说i和j要错开来类似双指针，i遍历，j满足条件后才继续遍历)
    if(p[i]==p[j+1]) j++;//如果尾部等于头部，j向右移动一次 下一次循环判断第二个和最后一个是否相同 例如a？a？
    ne[i]=j;//把j的值赋给next，j若一直在原点，说明没有相同前缀后缀(j每次遍历有几次和i相同，有几次那么公共前缀就有几个)
    }
    
    //匹配字符串
    for(int i=1,j=0;i<=m;i++){
        while(j && s[i]!=p[j+1]) j=ne[j];//j+1和i是同一终点，如果这两个值不同匹配不成功，那么p数组要移动，移动的位置满足匹配公共前缀即可，无需从头匹配
        if(s[i]==p[j+1]) j++;//如果匹配，j继续遍历
        if(j==n){
            printf("%d ", i - n);//j下标从0开始 输出起始下标出现的点
            j=ne[j];//匹配数组遍历完后，要继续移动的话。j的起点变成包括j之前的字符串前缀，例如abcaabca c==c，再次移动把a挪到第三个a的位置作为起点
        }
        
    }
    return 0;
    
    
}
```

- kmp算法两个步骤，1是求出next数组，next数组存储字符串公共前缀的最大个数，对应每一个数组元素下标。复杂度降为O(N).
- 2是匹配字符串每个元素，如果相同则j++继续匹配，如果不同匹配不成功时，通过ne[j]就可以快速拉到公共前缀下面对应。
- 注意：求next数组时，i设为2，j设为0 这样岔开可以快速通过j的值在给ne[]数组赋值时。因为j从0开始，每每匹配成功一个ne数组加1。

### Trie树

```c++
int son[N][26];//26个英文字母
int cnt[N];//记录扫描后每种字符串个数
int idx;//用了多少个节点

//插入字符串
void insert(char *str){
    int p=0;//用来记录下一个节点，类似指针。
    for(int i=0;str[i];i++){
        int u=str[i]-'a';
        if(!son[p][u]) son[p][u]=++idx;//如果这个节点是空的，那么创建下一个节点 如果不是空的 那用不到下一个节点，p还是这个节点
        p=son[p][u];//p指向下一个节点
    }
    cnt[p]++;
}

//查询字符串出现的次数
int query(char *str){
    int p=0;
    for(int i=0;str[i];i++){
        int u = str[i]-'a';
        if(!son[p][u]) return 0;//没找到返回0
        p=son[p][u];
    }
    return cnt[p];
}

/*这里刚开始搞乱的点是idx和p，idx是全局变量，也就是说每次插入字符串，在for循环中idx的值是一直在增大的，如果字符串不同不会有重合的清况*/
本质就是一颗多叉树，
    插入操作：先遍历字符串里每个元素，然后-'a'作为一个二维数组二级下标，初始化p=0作为一级下标一起存进树中.如果这个二维数组不存在，就创建下一个节点。节点是全局变量，不会清0 所以可以保证这个树不会重合。用cnt数组存储扫描完后这个字符串出现次数。如果出现两次abc字符串，第二次出现后，son[p][u]++idx的值不会增加。所以这个字符串次数出现两次。
    查询操作：遍历字符串每个元素，如果树里不存在这个元素对应的下标则说明字符串不存在。若存在返回cnt即可
```

- eg：最大异或对在给定的 NN 个整数 A1，A2……ANA1，A2……AN 中选出两个进行 xorxor（异或）运算，得到的结果最大是多少？

  ```c++
  #include<iostream>
  using namespace std;
  const int N =1e5+10,M=31*N;
  int son[M][2];
  int a[N];
  int idx;
  
  void insert(int x){
      int p=0;
      for(int i=30;i>=0;i--){//32位，第一位是符号位，这题是正数不管
          int u=x>>i&1;//从高位往低位取数，查看自己这个数是0还是1
          if(!son[p][u]) son[p][u]=++idx;//如果这个数不在，创建新节点
          p=son[p][u];//p指向下一个节点或者不变
      }
  }
  
  int search(int x){
      int p=0;int res=0;
      for(int i=30;i>=0;i--){
          int u=x>>i&1;
          if(son[p][!u]){//如果取出来自身数是1，为了异或最大应该找0.
              res=res*2+1;//与自身相反的数存在，则之前记录的值左移1位加1（0和1异或==1）
              p=son[p][!u];//p指向找到最大异或的节点
          }else{
              res=res*2+0;//找不到异或最大值，则这个数异或后是0
              p=son[p][u];
          }
      }
      return res;
  }
  
  int main(){
      int n;
      cin.tie(0);
      cin>>n;
      for(int i=0;i<n;i++){
          cin>>a[i];
          insert(a[i]);
          
      }
      
      int res=0;
      for(int i=0;i<n;i++){
          res=max(res,search(a[i]));
      }
      cout<<res;
      return 0;
  }
  ```

  - 这题主要用了字符查找树，如果用暴力时间复杂度是O(n^2),时间复杂度是O(31n)。字典树不仅可以高效的存储和查找字符串集合，还可以存储二进制数字。
  - 有类似出现很多字符并且要求查找或者做运算需要取出来的，都可以考虑字典树。这题思路是吧插入的数用二进制形式存储在树里，异或求最大值的本质就是找不同的二进制位做运算。所以我们每次要追求找到！u，找到了就是我们要找的最大值。找不到就只能顺着下一个小位的二进制继续查找！u，最后我们吧最值返回。

### 并查集

```c++
//朴素并查集
int p[N];//存储每个点的祖宗节点

//返回x的祖宗节点
int find(int x){
	if(p[x]!=x) p[x]=find(p[x]);//如果x不是自己的祖宗节点，则继续向上找x父节点的祖宗节点，如果父节点就是祖宗节点 则返回下面的父节点
	return p[x];//找到祖宗节点返回
}
//初始化，假定节点编号是1~n
for(int i=1;i<=n;i++) p[i]=i;
//合并a和b所在的两个集合
p[find(a)]=find(b);//a集合祖宗节点的祖宗节点是b集合的祖宗节点,a在b下面

(2)
//维护size的并查集：
int p[N],size[N];//size只有祖宗节点的有意义，表示祖宗节点所在集合中点的数量

int find(int x){
    if(p[x]!=x) p[x]=find(p[x]);
    return p[x];
}

for(int i=1;i<=n;i++){
    p[i]=i;
    size[i]=1;
}

//合并a和b所在的两个集合
size[find(b)]+=size[find(a)];//这一句不能写在合并前面，否则size结果会多算
p[find(a)]=find(b);

(3)
//维护到祖宗节点距离的并查集
int p[N],d[N];//d[x]存储x到p[x]的距离，也就是x到父节点的距离

int find(int x){
    if(p[x]!=x){
        int u =find(p[x]);//用中间变量存储x的祖宗节点 如果直接p[x]=find(p[x])，p[x]直接成为祖宗节点，下面会算少 
        d[x]+=d[p[x]];//x到父节点的距离加上父节点到祖宗节点的距离(压缩后d[1]=d[1](1)+d[2](d[2]由前面的递归返回，为2)=3)
        p[x]=u;//每个点的父节点指向根节点
    }
    return p[x];
}

// 初始化
for(int i=1;i<=n;i++){
    p[i]=i;
    d[i]=0;
}

//合并a和b所在的两个集合
p[find(a)]=find(b);
d[find(a)]=distance;

```

- eg 食物链

- ```c++
  #include<iostream>
  using namespace std;
  const int N = 1e5+10;
  int p[N],d[N];
  
  int find(int x){
      if(p[x]!=x){
          int u=find(p[x]);//用中间变量来存储父节点的根节点
          d[x]+=d[p[x]];//x到父节点的距离加上父节点到根节点的距离等于x到根节点的距离
          p[x]=u;//父节点指向根节点
      }
      return p[x];
  }
  
  int main(){
      int n,m;
      cin>>n>>m;
      
      //初始化p数组
      for(int i=1;i<=n;i++) p[i]=i;
      
      int res=0;//记录说谎话的个数
      
      while(m--){
          int t,x,y;
          cin>>t>>x>>y;
          
          //最明显的情况
          if(x>n || y>n) res++;
          else{
              int px=find(x),py=find(y);
              if(t==1){
                  if(px == py && (d[x]-d[y])%3) res++;//如果余3不等于0，说明不是同类
                  else if(px!=py){//根节点不同
                      p[px]=py;//px归在py集合内
                      d[px]=d[y]-d[x];//d[x]+d[px]-d[y])%3 == 0
                  }
              }else{
                  if(px == py && (d[x]-d[y]-1)%3) res++;//x比y大一，是真话，反之是假话
                  else if(px!=py){
                      p[px]=py;
                      d[px]=1+d[y]-d[x];//d[x]+d[px]-d[y]-1)%3
                  }
              }
          }
      }
      cout<<res<<endl;
      return 0;
  }
  ```

  - 食物链用到了带权并查集的思想，a被b吃，b被c吃。也就是b比a大1，c比b大1，c被a吃实际可以空想出一个d在c的下面，d比c大1也就是a比c大1，所以(a-c)%3==0、 (c-b)%3==1，因此我们可以额外维护一个d数组用来存储节点到根节点的距离，再通过余数是多少来判断是否同类还是异类生物。

### 堆排序

```c++
//h[N]存储堆中的值，h[1]是堆顶,x的左儿子是2x，右儿子是2x+1
//ph[k]存储第k个插入的点在堆中的位置(下标)
//hp[k]存储的是堆中下标是k的点是第几个插入的(idx)
int h[N],ph[N],hp[N],mysize;

//交换两个点及其映射关系
void heap_swap(int a,int b){
    swap(ph[hp[a]],ph[hp[b]]);
    swap(hp[a],hp[b]);
    swap(h[a],h[b]);
}

void down(int u){
    int t=u;
    if(u*2<=mysize && h[u*2]<h[t]) t=u*2;
    if(u*2+1<=mysize && h[u*2+1]<h[t]) t=u*2+1;
    if(t!=u){//未满足生成最小堆条件
        heap_swap(u,t);
        down(t);
    }
}

void up(int u){
    while(u/2 && h[u]<h[u/2]){
        heap_swap(u,u/2);
        u>>=1;//u除2继续向上生成最小堆
    }
}

//建堆
for(int i=n/2;i;i--) down(i);//i从倒数第二层开始遍历，则可完全遍历完堆
```

![838堆排序-1.png](https://cdn.acwing.com/media/article/image/2021/02/03/13021_4e8b9d6e65-838%E5%A0%86%E6%8E%92%E5%BA%8F-1.png)

- 模拟堆

- ```c++
  #include<iostream>
  #include<algorithm>
  #include<string.h>
  using namespace std;
  const int N = 1e5+10;
  int h[N],ph[N],hp[N],mysize;
  
  void heap_swap(int a,int b){//这个函数难点在于维护堆数组下标k和节点idx的映射关系
      //ph[idx]=k 表示的是堆中节点idx的下标是k
      //hp[k]=idx 表示的是堆中下标是k的节点是idx
      swap(ph[hp[a]],ph[hp[b]]);
      swap(hp[a],hp[b]);
      swap(h[a],h[b]);
  }
  
  void down(int u){
      int t=u;
      if(2*u<=mysize && h[2*u]<h[t]) t=2*u;//向下构建叶子下标不超过数组最大下标即可
      if(2*u+1<=mysize && h[2*u+1]<h[t]) t=2*u+1;
      if(t!=u){
          heap_swap(u,t);//如果最小堆还没有遍历完，则交换父节点和叶子
          down(t);//然后从叶子地方继续向下遍历生成最小堆
      }
  }
  
  void up(int u){
      while(u/2 && h[u/2]>h[u]){
          heap_swap(u/2,u);//如果父节点比叶子大，交换两个节点
          u>>=1;//继续向上遍历生成最小堆树
      }
  }
  
  int main(){
      int n,m=0;
      cin>>n;
      while(n--){
          char op[5];
          int k,x;
          cin>>op;
          if(!strcmp(op,"I")){
              cin>>x;
              mysize++;
              m++;
              ph[m]=mysize,hp[mysize]=m;//h[maxn] 表示堆
  //hp[maxn] 表示堆 第 k 个数——> h中结点（point）编号的映射
  //ph[maxn] 表示堆 结点编号为 p 的 结点——> h中第 k 个数的映射
              h[mysize]=x;
              up(mysize);
          }else if(!strcmp(op,"PM")) cout<<h[1]<<endl;
          else if(!strcmp(op,"DM")){//删除头节点
              heap_swap(1,mysize);
              mysize--;
              down(1);//交换了根节点后再从根节点往下构建最小堆
          }else if(!strcmp(op,"D")){//删除第k个数
              cin>>k;
              k=ph[k];//把编号为k映射到h中第k个数赋值给k
              heap_swap(k,mysize);//把k和尾节点交换
              mysize--;//删除后总数-1；
              down(k);
              up(k);//然后继续构建最小堆，要么往上要么往下只有一个方向
          }else{
              cin>>k>>x;
              k=ph[k];//把编号为k映射到h中
              h[k]=x;
              up(k);
              down(k);//插入好新节点后继续构建最小堆
          }
      }
      return 0;
  }
  ```

  - 理解hp与ph数组
    从上面讨论的可以知道，ph数组主要用于帮助从idx映射到下标k，似乎有了ph数组就可以完成所有操作了，但为什么还要有一个hp数组呢？
    原因就在于在swap操作中我们输入是堆数组的下标，无法知道每个堆数组的k下标对应idx（第idx个插入），所以需要hp数组方便查找idx。

### 一般哈希

```c++
(1) 拉链法
	int h[N],e[N],ne[N],idx;
	
	//向哈希表中插入一个数
	void insert(int x){
		int k=(x%N+N)%N;
		e[idx]=x;
		ne[idx]=h[k];//这里的h[k]相当于头节点，每次插入新节点，向下移
		h[k]=idx;
		idx++;
	}
	
	//向哈希表中查询某个数是否存在
	bool find(int x){
		int k= (x%N+N)%N;//+n再取余是为了防止余数出现负值
		for(int i=h[k];i!=-1;i=ne[i]){//遍历所有单链表
			if(e[i]==x) return true;
		}
		return false;
	}
	
(2)开放寻址法
int h[N];
int mynull = 0x3f3f3f3f;//mynull是自己定义的，代表无穷大

//如果x在哈希表中，返回x的下标：如果x不在哈希表中，返回x应该插入的位置
int find(int x){
	int k=(x%N+N)%N;
	while(h[k]!= mynull && h[k]!=x){//遍历哈希数组，如果位置被人占了并且占的人不是x，则右移继续遍历
		k++;
		if(k==N) k=0;//如果下标已经遍历到尾，k从0重新开始
	}
	return k
}
```

### 字符串哈希

```c++
核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低
小技巧：取模的数用2^64，这样直接用 unsigned long long存储，溢出的结果就是取模的结果

typedef unsigned long long ULL;
ULL h[N],p[N];//h[k]存储字符串前k个字母的哈希值，p[k]存储P^k mod 2^64

//初始化
p[0]=1;//初始化为1
//构造前缀和数组
for(int i=1;i<=n;i++){//为了方便求前缀和，下标从1开始
	h[i]=h[i-1]*P+str[i];//abcd=abc一起进位加1
	p[i]=p[i-1]*P;
}

//计算子串str[l~r]的哈希值(求前缀和)
ULL get(int l,int r){
	return h[r]-h[l-1]*p[r-l+1];//abcd-ab=cd
}
```

## 搜索与图论

### dfs深度优先搜索

- eg 八皇后问题

```c++
//枚举每一个位置 时间复杂度O(2^n^2)

#include<bits/stdc++.h>
using namespace std;
const int N = 10;
int n;
bool row[N],col[N],dg[N*2],udg[N*2];
char g[N][N];

void dfs(int x,int y,int s){
    if(s>n) return ;//已经找到八个皇后，现在是第九个
    if(y==n) x++,y=0;//走完一行，走下一行
    if(x==n){//x已经超过了8行 0~7
        if(s==n){//如果先前已经找到第八个皇后，就输出结果
            for(int i=0;i<n;i++) puts(g[i]);
            cout<<endl;
        }
        return ;
    }
    g[x][y]='.';//初始化为.
    //不放皇后
    dfs(x,y+1,s);//每次向右遍历一个小格
    //放皇后
    if(!row[x] && !col[y] && !dg[x+y] && !udg[x-y+n]){
        g[x][y]='Q';//符合条件就是Q
        row[x]=col[y]=dg[x+y]=udg[x-y+n]=true;
        dfs(x,y+1,s+1);//遍历每个格子，此时找到s+1个皇后
        g[x][y]='.';
        row[x]=col[y]=dg[x+y]=udg[x-y+n]=false;
    }
}

int main(){
    cin>>n;
    dfs(0,0,0);
    return 0;
}

**************************************************************************************
//枚举每一行 时间复杂度 O(n^2)
#include<bits/stdc++.h>
using namespace std;
const int N =20;
bool col[N],dg[N],udg[N];
char g[N][N];
int n;

//dfs搜索

void dfs(int u){
    if(u==n){//遍历到第八行
        for(int i=0;i<n;i++) puts(g[i]);
        puts("");
        return ;
    }

    for(int i=0;i<n;i++){//遍历每一列 每次u+1相当于遍历每一行 所以不用rows[]
        if(!col[i] && !dg[u+i] && !udg[u-i+n]){
            g[u][i]='Q';
            col[i] = dg[u+i] = udg[u-i+n] =true;
            dfs(u+1);
            col[i]=dg[u+i] = udg[u-i+n]=false;
            g[u][i]='.';//第一个结果出来后，全部回溯
        }
    }
}

int main(){
    cin>>n;
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            g[i][j]='.';
        }
    }
    dfs(0);
    return 0;
}
```

- 枚举每一个位置的递归返回需要注意，s是找到皇后数量，一共有八个所以s要大于n。而x和y下标是从0开始，==n已经是超过了7，所以需要返回。另外枚举每一个方格，有选择走或者不走两条路，对应两个dfs。

### bfs宽度搜索

- 走迷宫

  ![image-20220921194341436](C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20220921194341436.png)

  - ```c++
    #include<iostream>
    #include<queue>
    #include<cstring>
    using namespace std;
    const int N = 110;
    queue<pair<int,int>> q;
    int g[N][N];//存储地图
    int d[N][N];//存储离起点距离
    int n,m;
    
    int bfs(){
        memset(d,-1,sizeof d);//把所有离起点的点初始化距离为-1
        d[0][0]=0;//0已经被走过
        q.push({0,0});//走过0点就把它压入队列
        while(!q.empty()){//如果队列不为空
            auto t = q.front();//取出队头
            q.pop();//删掉队头
            
            int x =t.first,y=t.second;
            int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};//上下左右四个方向
            for(int i=0;i<4;i++){
                int a=x+dx[i],b=y+dy[i];
                if(a>=0 && a<n && b>=0 && b<m && g[a][b]==0 && d[a][b]==-1){//没超过边界并且这个点不是墙壁（1），以及这个点没有被走过
                    d[a][b]=d[x][y]+1;//这个点离起点的距离是上一个点加一
                    q.push({a,b});//把这个点压入队列，准备下次循环取出
                }
            }
        }
        return d[n-1][m-1];
    }
    
    int main(){
        cin>>n>>m;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                cin>>g[i][j];
            }
        }
        cout<<bfs()<<endl;
    }
    ```

    - 走迷宫是一道求最短路径bfs例题，我们可以用队列的数据结构。每次走到下一格，队头就是这个格子。然后上下左右遍历，符合条件的路径长度加1，最后返回右下角坐标的路径长度。（最快返回路径的就是最短路径）

### 树与图

```c++
树与图的存储

int h[N],e[N],ne[N],idx;
void add(int a,int b){
	e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}
memset(h,-1,sizeof h);//头节点全部初始化为-1

***************************************************************
树与图的遍历 O(n+m) 点数加边数

int dfs(int u){
	st[u]=true;//表示u已经被遍历过
	
	for(int i=h[u];i!=-1;i=ne[i]){
		int j= e[i];
		if(!st[j]) dfs(j);
	}
}

queue<int> q;
st[1]=true;//编号为1的点已经遍历过
q.push(1);//把编号为1压入

while(q.size()){
	int t =q.front();
	q.pop();
	
	for(int i=h[t];i!=-1;i=ne[i]){
		int j = e[i];
		if(!st[j]){
			st[j]=true;//表示该点已经走过
			q.push(j);
		}
	}
}

```

- 树的重心

- ```c++
  #include<bits/stdc++.h>
  using namespace std;
  const int N =1e5+10;
  int h[N],e[N*2],ne[N*2],idx;
  bool st[N];
  int n;
  int ans=N;//全局变量，存储最大联通块的最小值
  
  //插入构建无向边树
  void add(int a,int b){
      e[idx]=b;
      ne[idx]=h[a];
      h[a]=idx;
      idx++;
  }
  
  int dfs(int u){//返回以u为根的子树的大小
      st[u]=true;//代表这个点已经走过
      int sum=1,num=0;//sum是当前u节点子树的节点数，num是所有联通块最大节点数
      for(int i=h[u];i!=-1;i=ne[i]){//遍历根节点每一条边
          int j = e[i];
          if(st[j]) continue;//如果这个点走过，退出for循环
          int s= dfs(j);//取得以j为根的子树的节点数
          num = max(num,s);//得到当前最大的联通块
          sum+=s;//当前子树节点数加s
      }
      num=max(num,n-sum);//找出以这节点分割的联通快节点数
      ans=min(num,ans);//和全局变量min求出最小联通块
      return sum;
  
  }
  
  int main(){
      memset(h,-1,sizeof h);
      cin>>n;
      int a,b;
      for(int i=0;i<n;i++){//用while n-- 只循环八次
          cin>>a>>b;
          add(a,b);
          add(b,a);
      }
      dfs(1);
      cout<<ans;
      return 0;
  }
  ```

  - 这题的主要思想是dfs搜索树，从根节点开始，每次向下遍历一个节点，求出以这个节点为根节点的子树节点数量，从而求得最大联通块的节点数，通过每次和全局变量ans对比，就能得到最小联通快数量。返回类型是int，因为要得到每个节点做根节点时的sum。

- 图中点的层次

- ```c++
  #include<bits/stdc++.h>
  using namespace std;
  const int N =1e5+10;
  int e[N],ne[N],d[N],h[N],idx;
  int q[N];//数组模拟队列
  int n,m;
  
  void add(int a,int b){
      e[idx]=b;
      ne[idx]=h[a];
      h[a]=idx;
      idx++;
  }
  
  int bfs(){
      int hh=0,tt=0;
      memset(d,-1,sizeof d);//把所有离起点距离初始化为-1
      q[0]=1;//第一个元素编号为1
      d[1]=0;//编号为1已经走过，离起点长为0
      while(hh<=tt){
          int t = q[hh++];//取出队列头
          for(int i=h[t];i!=-1;i=ne[i]){//遍历队列
              int j = e[i];//取出i下标对应的值
              if(d[j]==-1){//走的点之前没走过
                  d[j]=d[t]+1;//比上一步多走1
                  q[++tt]=j;//在队列尾插入新值
              }
          }
      }
      return d[n];
  }
  
  int main(){
  
      cin>>n>>m;
      memset(h,-1,sizeof h);
      for(int i=0;i<m;i++){
          int a,b;
          cin>>a>>b;
          add(a,b);
      }
      cout<<bfs();
      return 0;
  }
  ```

  - 这里筛选条件是d[n]!=-1，意思是如果这个点没走过，替代了state[n]=false
  - q数组存储元素编号，d是编号离起点的距离。bfs问题就是不停取出队头，然后判断队头走的方向是否可取，可取则距离加1，压入队列尾等待下一次取出队头，不可取则遍历下一个。

### 拓扑序列

```c++
时间复杂度O(N+M),n表示点数，m表示边数
//用数组模拟的方式来写拓扑序列，才能存下来拓扑序列的结果

bool topsort(){
	int hh=0,tt=-1;
	
	//d[i]存储i的入度
	for(int i=1;i<=n;i++){//找出度为0的点作为队列头放入队列中
		if(!d[i]){
			q[++tt]=i;
		}
	}
	while(hh<=tt){//直到队为空
		int t = q[hh++];
		for(int i =h[t];i!=-1;i=ne[i]){//遍历每一条边
			int j=ne[t];
			if(--d[j]==0){//度数等于1，减去后变成0作为新度压入队列中
				q[++tt]==j;
			}
		}
	}
	return tt==n-1;//tt从0开始，最后恰好等于n-1，如果n个数成功入队，说明满足拓扑序列
}
```

### 朴素dijkstra

```c++
时间复杂度 O(n^2+m),n是点数，m是边数

int g[N][N];//存储每一条边
int dist[N];//存储1号点到每个点的最短距离
bool st[N];//存储每个点的最短路是否已经确定

//求1号点到n号点的最短路，如果不存在则返回-1
int dijkstra(){
	memset(dist,0x3f,sizeof dist);
	dist[1]=0;
	
	for(int i=0;i<n-1;i++){//最后一个点只更新了距离并且已经确定是最短距离，所以不需要再考虑加入st[n]的操作
		int t =-1;//便于寻找第一个点
		for(int j=1;j<=n;j++){
			if(!st[j] && (t==-1 || dist[t]>dist[j])){
				t=j;
			}
		}
		st[t]=true;//最短路被确认
	}
	if(dist[n]==0x3f3f3f3f) return -1;
	else return dist[n];
}
```

- eg朴素dijkstra算法模板题

- ```c++
  #include<iostream>
  #include<cstring>
  #include<algorithm>
  using namespace std;
  const int N = 510;
  int g[N][N],dist[N];
  bool st[N];
  int n,m;
  
  int dijkstra(){
      memset(dist,0x3f,sizeof dist);//初始化距离
      dist[1]=0;//起点到起点距离为0
      
      for(int i=1;i<=n;i++){
          int t=-1;//为了方便找出第一个点 t作为中间变量临时存储每次找到未确认的最短路径节点
          for(int j=1;j<=n;j++){
              if(!st[j] && (t==-1 || dist[j]<dist[t])){//找到没确定路径的节点中的最短距离(就是找哪个点最近)
                  t=j;
              }
          }
          st[t]=true;//经过上面的for循环 这个点最短路径已经找到
          
          for(int j=1;j<=n;j++){
              //起点到j的距离和起点到t在到j的距离
              dist[j]=min(dist[j],dist[t]+g[t][j]);//已经确定了最短距离的点，继续更新它周边的点最短距离
          }
      }
      if(dist[n]==0x3f3f3f3f) return -1;//memset初始化每个字节，所以数组内值是四个字节的3f
      else return dist[n];
      
      
  }
  
  int main(){
      cin>>n>>m;
      memset(g,0x3f,sizeof g);//把邻接矩阵权值初始为无穷大
      while(m--){
          int a,b,c;
          cin>>a>>b>>c;
          g[a][b]=min(g[a][b],c);//重边情况取最小值
      }
      int t = dijkstra();
      cout<<t;
      return 0;
  }
  ```

  - 思路是先遍历每一个点出发，然后第二层遍历每一条边找到未确认最短路径的点，再更新最短路径点周围的点。

### 堆优化dijkstra

![image-20220924102236519](C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20220924102236519.png)

```c++
typedef pair <int,int> PII;
int n;      // 点的数量
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储所有点到1号点的距离
bool st[N];     // 存储每个点的最短距离是否已确定

//求1号点到n号点的最短距离，如果不存在，则返回-1
int dijkstra(){
	memset(dist,0x3f,sizeof dist);
	dist[1]=0;//编号为1的点离起点距离0
	priority_queue<PII,vector<PII>,greater<PII>> heap;
	heap.push({0,1});//first存储距离，second存储节点编号
	
	while(heap.size()){
		auto t = heap.top();//每次取出队头
		heap.pop();
		int distance = t.first,ver=t.second;
		if(st[ver]) continue;//如果当前点最短路径已经确定，退出然后取队列下一个值
		st[ver]=true;//标记当前点已经确认
		
		for(int i=h[ver];i!=-1;i=ne[i]){//遍历更新周围更短路径的点
			int j=e[i];
			if(dist[j]>dist[ver]+w[i]){//起点到j的值大于起点到ver再到j
				dist[j]=distance+w[i];
				heap.push({dist[j],j});//压入队列中
			}
		}
	}
	if(dist[n]==0x3f3f3f3f) return -1;
	return dist[n];
	
}
```

- 堆优化的dijkstra时间复杂度是 O(mlogn),朴素算法为了找到未确认最短路径的点，用了两层for循环，而最小堆找最短点时间复杂度是O(1).
- 思路是先创建一个最小堆priority_queue,每次取出队头也就是当前离起点最近的点，再从这个点去找周边的点，然后更新它们的最短路径。

### Bellman-Ford

![image-20220925153553970](C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20220925153553970.png)

```c++
时间复杂度 O(nm)O(nm), nn 表示点数，mm 表示边数

int n,m;//n表示点数，m表示边数
int dist[N];//dist[x]存储1到x的最短路距离

struct Edge
{
	int a,b,w;
}edges[M];

//求1到n的最短路距离，如果无法从1走到n，返回-1
int bellman_ford(){
	memset(dist,0x3f,sizeof dist);
	dist[1]=0;
	
	//如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。
	for(int i=0;i<n;i++){
		for(int j=0;j<m;j++){
			int a=edges[j].a,int b=edges[j].b,w=edges[j].w;
			if(dist[b]>dist[a]+w){
				dist[b]=dist[a]+w;
			}
		}
		if(dist[n]>0x3f3f3f3f/2) return -1;//dist[b]=dist[a]+w;未更新的点被边更新，2+无穷！=无穷，返回dist就错了
		return dist[n];
	}
}
```

- eg有边数限制的最短路

- ```c++
  #include<iostream>
  #include<cstring>
  using namespace std;
  const int N =510,M=10010;
  int dist[N];
  int back[N];//防止出现串联
  int n,m,k;
  
  struct bellmanford{
      int a;
      int b;
      int w;
  }edges[M];
  
  void bellman_ford(){
      memset(dist,0x3f,sizeof dist);
      dist[1]=0;
      for(int i=0;i<k;i++){//示从 1 号点到 n 号点的最多经过 k 条边的最短距离 遍历k条边
          //每次你只能走一条边，如果不拷贝当前dist，下面更新最短距离会出错 1->2->3 中间两条边权值是1，1->3权值是2，
          //只走一条边，最短路径是3不是2，所以要用back存好a边更新前的权值
          memcpy(back,dist,sizeof dist);//dista会变 防止a更新后把b一起更新，这样b一次性最短路径就多了两条边出来 引发串联
          for(int j=0;j<m;j++){
              bellmanford e = edges[j];
              dist[e.b]=min(dist[e.b],back[e.a]+e.w);//更新最短路径
          }
      }
  }
  
  int main(){
      cin>>n>>m>>k;
      for(int i=0;i<m;i++){
          int a,b,w;
          cin>>a>>b>>w;
          edges[i]={a,b,w};
          
      }
      
      bellman_ford();
      if(dist[n]>0x3f3f3f3f/2) puts("impossible");//边权最大是10000^2 0x3f3f3f3f/2是十多亿
      else cout<<dist[n];
      return 0;
  }
  ```

  - 这个算法适用于存在负边权和存在负回路的情况，而且题目中有限定在k条边找到最短路，只能用bellman_ford算法，dijkstra只能用于正边权。思路是遍历每一个点，back记录未更新前的出边权值，再去遍历每条边，更新最短路径。

### spfa

(松弛)

- 考虑节点u以及它的邻居v，从起点跑到v有好多跑法，有的跑法经过u，有的不经过。

  经过u的跑法的距离就是distu+u到v的距离。

  所谓松弛操作，就是看一看distv和distu+u到v的距离哪个大一点。

  如果前者大一点，就说明当前的不是最短路，就要赋值为后者，这就叫做松弛。

```c++
时间复杂度 平均情况下 O(m)，最坏情况下 O(nm), n 表示点数，m 表示边数

int n;//总点数
int h[N],w[N],e[N],ne[N],idx;//邻接表存储所有边
int dist[N];//存储每个点到1号点的最短距离
bool st[N];//存储每个点是否在队列中

//求1号点到n号点的最短距离，如果从1号点无法走到n号点返回-1

int spfa(){
	memset(dist,0x3f,sizeof dist);
	dist[1]=0;//1号点离起点距离0
	
	queue<int> q;
	q.push(1);//队列压入编号为1的点
	st[1]=true;//1号已经在队列中了
	
	while(q.size()){
		auto t =q.front();
		q.pop();
		
		st[t]=false;//每次弹出队头，队列中就没有这个元素
		
		for(int i=h[t];i!=-1;i=ne[i]){
			int j = e[i];
			if(dist[j]>dist[t]+w[i]){//更新最短路径
				dist[j]=dist[t]+w[i];
				if(!st[j]){//如果队列中没有j再压入，有就不压入，但是dist再前面已经被更新了，j之前最短路路径仍然更新。但是队列中有j，说明此时未更新到j点，压入新j到队列也毫无意义，两个j到最后只会出来一个更新，所以此步为了节省效率，只压进已经更新过的点。只有这个点被确认更新，后面的点最短路才有意义。
					q.push(j);
					st[j]=true;
				}
			}
		}
	}
	if(dist[n]==0x3f3f3f3f) return -1;
	return dist[n];
}
```

- spfa求最短路

- ```c++
  #include<bits/stdc++.h>
  using namespace std;
  const int N =100010;
  int n, m;
  int h[N], w[N], e[N], ne[N], idx;
  int dist[N];
  bool st[N];
  
  void add(int a, int b, int c)
  {
      e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
  }
  
  int spfa(){
      memset(dist,0x3f,sizeof dist);
      dist[1]=0;
      
      queue<int> q;
      q.push(1);
      st[1]=true;//编号为1的点已在队列中
      
      while(q.size()){
          int t =q.front();
          q.pop();
          st[t]=false;//弹出来就不在队列中
          
          for(int i=h[t];i!=-1;i=ne[i]){//遍历每条边
              int j = e[i];
              if(dist[j]>dist[t]+w[i]){
                  dist[j]=dist[t]+w[i];//更新最小路径
                  if(!st[j]){//如果不在队列
                      q.push(j);//放入队列中
                      st[j]=true;//标记已在队列
                  }
              }
          }
      }
      return dist[n];
  }
  
  int main(){
      cin>>n>>m;
      memset(h,-1,sizeof h);
      for(int i=0;i<m;i++){
          int a,b,c;
          cin>>a>>b>>c;
          add(a,b,c);
      }
      int t =spfa();
      if(t == 0x3f3f3f3f) puts("impossible");//这里最后返回的dist如果没被更新，就是3f3f3f3f,而bellman_ford没更新的点也会被前面的边更新
      else cout<<t;
      return 0;
      
  }
  ```

  - spfa算法比bellman_ford优化了压入队列的步骤，每次只压入队列中没有的点，只有确认更新后的点，才对后面点的最短路有意义。但是不适用于k条边限制。。**Bellman_ford算法可以存在负权回路，是因为其循环的次数是有限制的因此最终不会发生死循环；但是SPFA算法不可以，由于用了队列来存储，只要发生了更新就会不断的入队，因此假如有负权回路请你不要用SPFA否则会死循环**
  - 思路是每次从队列弹出队头，然后标记false代表队列已无此元素。再遍历它的每一条边更新最短路径。如果新路径的节点队列中没有，就压入，如果有说明此点还未被更新，只更新dist不再压入队列中，队列中没有元素，说明已经走完。
  -  **Bellman_ford算法会遍历所有的边，但是有很多的边遍历了其实没有什么意义，我们只用遍历那些到源点距离变小的点所连接的边即可，只有当一个点的前驱结点更新了，该节点才会得到更新**, 和bellman_ford不同的是，bellman_ford在未确认更新点前会遍历每一条边去更新到这条边，例如2+无穷，而spfa从点到点，不会有边权更新点的情况，所以主函数判断条件有所不同
  - **DIjkstra算法是根据贪心的，一旦确定了最短路就会被确定，有负权边就会忽略更短的距离，但是spfa和bf都是在枚举边，所以就可以去不断的去枚举。**

#### spfa判断负环存在

```c++
int n;
int h[N],e[N],ne[N],idx;
int dist[N],cnt[N];//cnt[x]存储1到x的最短路中经过的点数
bool st[N];

//如果存在负环返回true
bool spfa(){
	// 不需要初始化dist数组
    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。
    
    queue<int> q;
    for(int i=1;i<=n;i++){//处理不连通图，比如1点未必能到负权回路的点
    	q.push(i);
    	st[i]=true;
    }
    
    while(q.size()){
    	auto t = q.front();
    	q.pop();
    	
    	st[t]=false;
    	
    	for(int i=h[t];i!=-1;i=ne[i]){
    		int j =e[i];
    		if(dist[j]>dist[t]+w[i]){//遇到负权更新
    			dist[j]=dist[t]+w[i];
    			cnt[j]=cnt[t]+1;//这里记录的是负权点，dist未初始化都为0
    			if(cnt[j]>=n) return true;// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环
    			if(!st[j]){
    				q.push(j);
    				st[j]=true;
    			}
    		}
    	}
    }
    return false;
}

```

- eg spfa判断负环

- ```c++
  #include<iostream>
  #include<queue>
  #include<cstring>
  using namespace std;
  const int N =1e5+10;
  int h[N],e[N],w[N],ne[N],idx;
  int dist[N],count[N];
  bool st[N];
  int n,m;
  
  void add(int a,int b,int c){
      e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;
  }
  
  bool spfa(){
      // memset(dist,0x3f,sizeof dist);//这里可以不用初始化dist，只要存在负回环 不管dist是多大都会被更新
      queue<int> q;
      for(int i=1;i<=n;i++){//将所有点插入队列只是为了处理不连通的问题
          q.push(i);
          st[i]=true;
      }
      
      while(q.size()){
          auto t = q.front();
          q.pop();
          st[t]=false;
          
          for(int i=h[t];i!=-1;i=ne[i]){
              int j = e[i];
              if(dist[j]>dist[t]+w[i]){//遇到负权边时候更新
                  dist[j]=dist[t]+w[i];
                  count[j]=count[t]+1;// cnt等于负环上的节点数
                  if(count[j]>=n) return true;//抽屉原理，一共n个点最短路经过n+个负点 说明存在负回环
                  if(!st[j]){
                      q.push(j);
                      st[j]=true;
                  }
              }
              
          }
      }
      return false;
  }
  
  int main(){
      cin>>n>>m;
      memset(h,-1,sizeof h);
      while(m--){
          int a,b,c;
          cin>>a>>b>>c;
          add(a,b,c);
          
      }
      
      if(spfa()) puts("Yes");
      else puts("No");
      return 0;
  }
  ```

  - 在原图的基础上新建一个虚拟源点，从该点向其他所有点连一条权值为0的有向边。那么原图有负环等价于新图有负环。此时在新图上做spfa，将虚拟源点加入队列中。然后进行spfa的第一次迭代，**这时会将所有点的距离更新并将所有点插入队列中**。执行到这一步，就等价于视频中的做法了。那么视频中的做法可以找到负环，等价于这次spfa可以找到负环，等价于新图有负环，等价于原图有负环。得证。

### floyd

```c++
时间复杂度是O(n^3),n表示点数
    
//k相当于桥，如果先更新i或j，那么桥没更新完，i的最短路径就确立了。显然不对，因此k放外面

初始化：
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(i==j) d[i][j]=0;
			else d[i][j]=INF;
		}
	}
	
//算法结果后，d[a][b]表示a到b的最短距离
void floyd(){
	for(int k=1;k<=n;k++){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
			}
		}
	}
}
```

- f[i, j, k]表示从i走到j的路径上除i和j点外只经过1到k的点的所有路径的最短距离。**那么f[i, j, k] = min(f[i, j, k - 1), f[i, k, k - 1] + f[k, j, k - 1]。**
  **因此在计算第k层的f[i, j]的时候必须先将第k - 1层的所有状态计算出来**，所以需要把k放在最外层。

### prim

```c++
时间复杂度是 O(n2+m)O(n2+m), nn 表示点数，mm 表示边数
int n;      // n表示点数
int g[N][N];        // 邻接矩阵，存储所有边
int dist[N];        // 存储其他点到当前最小生成树的距离
bool st[N];     // 存储每个点是否已经在生成树中


// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和
int prim()
{
    memset(dist, 0x3f, sizeof dist);

    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        if (i && dist[t] == INF) return INF;

        if (i) res += dist[t];
        st[t] = true;

        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }

    return res;
}

```

- eg prim算法求最小生成树

- ```c++
  #include<bits/stdc++.h>//Dijkstra算法是更新到起始点的距离，Prim是更新到集合S的距离
  using namespace std;
  const int N = 510,INF=0x3f3f3f3f;
  int dist[N];
  int g[N][N];
  int n,m;
  bool st[N];
  
  int prim(){
      memset(dist,0x3f,sizeof dist);
  
      int res=0;
      for(int i=0;i<n;i++){
          int t=-1;
          for(int j=1;j<=n;j++){//找到离当前点最短的点
              if(!st[j] && (t==-1 || dist[t]>dist[j])){
                  t=j;
              }
          }
  
          //如果第一次，生成树只有一个点，不存在边的距离 所以特判i==0的情况
          if(i && dist[t]==INF) return INF;//不是第一个点且找到最近点的距离是无穷
          if(i) res+=dist[t];//加上最短路
          st[t]=true;//这点最短路已经找到
  
          for(int j=1;j<=n;j++){
              dist[j]=min(dist[j],g[t][j]);//g[t][j]表示t点到集合树的距离
          }
  
      }
      return res;
  }
  
  int main(){
      cin>>n>>m;
      memset(g,0x3f,sizeof g);
  
      while(m--){
          int u,v,w;
          cin>>u>>v>>w;
          g[u][v]=g[v][u]=min(g[u][v],w);
      }
  
      int t=prim();
      if(t==INF) puts("impossible");
      else cout<<t;
      return 0;
  
  }
  ```

  ### Kruskal
  
  ```c++
  时间复杂度是 O(mlogm)O(mlogm), nn 表示点数，mm 表示边数
  
  int n,m;
  int p[N];
  
  struct Edge{
  	int a,b,w;
  	
  	bool operator< (const Edge &t)const{//按边权从小到大排序
  		return w<t.w;
  	}
  }edges[M];
  
  int find(int x){
      if(p[x]!=x) p[x]=find(p[x]);
      return p[x];
  }
  
  int kruskal(){
      sort(edges,edges+m);
      for(int i=1;i<=n;i++) p[i]=i;
      
      int res=0,cnt=0;
      for(int i=0;i<m;i++){//依次尝试加入每条边
          int a=edges[i].a,b=edges[i].b,w=edges[i].w;
          a=find(a),b=find(b);
          if(a!=b){//两个集合不连通
              p[a]=b;//合并两个连通块
              res+=w;
              cnt++;
          }
      }
      if(cnt<n-1) return INF;//如果边数不全，则无法构成最小生成树
      return res;
  }
  ```
  
  - 算法思路：
  
    - 将所有边按照权值的大小进行升序排序，然后从小到大一一判断。
  
    - **如果这个边与之前选择的所有边不会组成回路，就选择这条边分；反之，舍去。**
  
    - 直到具有 n 个顶点的连通网筛选出来 n-1 条边为止。
  
  
    - 筛选出来的边和所有的顶点构成此连通网的最小生成树。
  
  
    - 判断是否会产生回路的方法为：使用并查集。
  
  
    - 在初始状态下给各个个顶点在不同的集合中。、
  
  
    - 遍历过程的每条边，判断这两个顶点的是否在一个集合中。
  
  
    - 如果边上的这两个顶点在一个集合中，说明两个顶点已经连通，这条边不要。如果不在一个集合中，则要这条边。

### 染色法判别二分图

```c++
时间复杂度是 O(n+m), n 表示点数，m 表示边数

int n;
int h[N], e[M], ne[M], idx;     // 邻接表存储图
int color[N];       // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色

//u表示当前节点，c表示当前点的颜色
bool dfs(int u,int c){
	color[u]=c;
	for(int i=h[u];i!=-1;i=ne[i]){//遍历当前点相邻的其他点
		int j=e[i];
		if(!color[j]){
			if(!dfs(j,3-c)) return false;//3-c 1下一个点是2，2下一个点是1 恰好隔开
		}else if(color[j]==c) return false;//如果下一个点和当前点颜色相同返回错
	}
	return true;
}
```

- eg染色法判定二分图

- ```c++
  #include<iostream>
  #include<cstring>
  using namespace std;
  const int N =2e5+10;//无向图开两倍边
  int h[N],e[N],ne[N],idx;
  int n,m;
  int color[N];//保存各个点的颜色，0 未染色，1 是红色，2 是黑色
  
  void add(int a,int b){
      e[idx]=b;
      ne[idx]=h[a];
      h[a]=idx;
      idx++;
  }
  
  bool dfs(int u,int c){
      color[u]=c;//u点染成c色
      for(int i=h[u];i!=-1;i=ne[i]){//遍历和u相邻的点
          int b = e[i];
          if(!color[b]){//如果这个点没染色
          //（3 - 1 = 2， 如果 u 的颜色是2，则和 u 相邻的染成 1）
          //（3 - 2 = 1， 如果 u 的颜色是1，则和 u 相邻的染成 2）
              if(!dfs(b,3-c)) return false;
          }else if(color[b] && color[b]!=3-c){//这个点染色了并且和上个点颜色相同
              return false;
          }
      }
      return true;
  }
  
  int main(){
      memset(h,-1,sizeof h);
      cin>>n>>m;
      while(m--){
          int u,v;
          cin>>u>>v;
          add(u,v),add(v,u);//无向图加两条边
      }
      
      for(int i=1;i<=n;i++){
          if(!color[i]){//如果这个点没染色
              if(!dfs(i,1)){//染1色然后处理它邻近点,如果不对
                  cout<<"No";
                  return 0;
              }
          }
      }
      cout<<"Yes";
      return 0;
  }
  ```

  - 思路：

  - 如果判断一个图是不是二分图？

    开始对任意一未染色的顶点染色。

    判断其相邻的顶点中，若未染色则将其染上和相邻顶点不同的颜色。

    若已经染色且颜色和相邻顶点的颜色相同则说明不是二分图，若颜色不同则继续判断。

    bfs和dfs可以搞定！

### 匈牙利算法

```c++
时间复杂度是 O(nm), n 表示点数，m 表示边数

int n1, n2;     // n1表示第一个集合中的点数，n2表示第二个集合中的点数
int h[N], e[M], ne[M], idx;     // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边
int match[N];       // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个
bool st[N];     // 表示第二个集合中的每个点是否已经被遍历过

bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }

    return false;
}

// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点
int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);//st数组才是匈牙利算法的精华。st数组就保证了，只有当左一还有备胎的时候，才会把右一让给别人；同时也防止无限递归。
    if (find(i)) res ++ ;
}

```

- eg二分图的最大匹配

- ```c++
  #include<bits/stdc++.h>
  using namespace std;
  const int N =510,M=1e5+10;
  int h[N],e[M],ne[M],idx;
  bool st[N];
  int n1,n2,m;
  int match[N];
  
  void add(int a,int b){
      e[idx]=b,ne[idx]=h[a],h[a]=idx++;
  }
  
  bool find(int x){
      for(int i=h[x];i!=-1;i=ne[i]){//遍历每一个喜欢的女生
          int j =e[i];
          if(!st[j]){//如果在这一轮模拟匹配中,这个女孩尚未被预定
              st[j]=true;//如果女孩没被预定 那就自己预定
              if(match[j]==0 || find(match[j])){//女孩没有男朋友 或者她男朋友喜欢别的女生 那就可以给她男友戴绿帽
                  match[j]=x;//夺人妻
                  return true;
              }
          }
      }
      return false;
  }
  
  int main(){
      cin>>n1>>n2>>m;
      memset(h,-1,sizeof h);
      
      while(m--){
          int a,b;
          cin>>a>>b;
          add(a,b);
      }
      
      int res=0;
      for(int i=1;i<=n1;i++){
          //假设左一和右一已经是一对，左二也看上了右一
          //如果每次不更新st为false，左二发现match[1]=1，然后左一再去find(1),左一发现match[1]=1，虽然就是他自己，但是他还是又去find(match[1]),所以就会一直递归下去。
          memset(st,false,sizeof st);//防止无限递归以及给其他男生机会追求女生
          if(find(i)) res++;
      }
      cout<<res;
      return 0;
  }
  ```

  

## 数学知识

### 线性筛

```c++
//朴素筛法-O(nlogn)
void get_primes(int n) {
    for(int i = 2; i <= n; i++) {
        if(!st[i]) prime[cnt++] = i;
        for(int j = i+i; j <= n; j += i) //for在外面，合数的倍数也标记 浪费效率
            st[j] = true;
    }
}

//埃式筛法-O(nloglogn)
int primes[N], cnt;     // primes[]存储所有素数
bool st[N];         // st[x]存储x是否被筛掉

void get_primes(int n) {
    for(int i = 2; i <= n; i++) {
        if(!st[i]){ 
            prime[cnt++] = i;
            for(int j = i; j <= n; j += i)//for在if里面，只标记质数的倍数
                st[j] = true;
        }
    } 
}

线性体现不能光理解成只筛掉合数，每次筛掉后下一个一定是质数，2~i-1都被标记，i一定是质数
//线性筛法-O(n), n = 1e7的时候基本就比埃式筛法快一倍了
//算法核心：x仅会被其最小质因子筛去//埃式筛法-O(nloglogn)

int primes[N],cnt;//primes[]存储所有素数
bool st[N];//st[]存储x是否被筛掉

void get_primes(int x){
	for(int i=2;i<=x;i++){
		if(!st[i]) primes[cnt++]=i;//如果没被筛选，就作为质数 顺序由小到大
		for(int j=0;primes[j]<=n/i;j++){//遍历从小到大的质数 遍历到n/i就可以，例如100 只需要知道2 3 5 7
			st[primes[j]*i]=true;//把最小质因数的倍数标记会true
			if(i%primes[j]==0) break;//如果i是合数，即最大质因子只有一个，退出循环
			//如果i是质数，说明primes[j]就是i，primes已经遍历到边界，此时退出循环
		}
	}
}

```

### 约数个数

```c++
如果 N = p1^c1 * p2^c2 * ... *pk^ck
约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)
约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)
    
eg: 360 = 2^3*3^2*5
    约数之和：
    (1：只取2为底数的约数  2^0+2^1+2^2+2^3
     2：取2、3为底数的约数  (2^0+2^1+2^2+2^3)*(3^1+3^2)
     3：取2、3、5为底数的约数 (2^0+2^1+2^2+2^3)*(3^0+3^1+3^2)*(5^1)
    )再加起来
    
    求和用秦九韶算法， t=1 while(指数--) t=t*p+1;
	eg:
		2^0+2^1+2^2+2^3 p=3,c=2
	   1:p+1
       2:p^2+p+1
       3:p^3+p^2+p+1
    
	和  (2^0+2^1+2^2+2^3)*(3^0+3^1+3^2)*(5^0+5^1)
    个数		c1 + 1			c2 + 1		c3 + 1
    		c1=3 			c2=2		c3=1
```

### 欧拉函数

#### 证明过程

![image-20220929204716253](C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20220929204716253.png)

![image-20220929204748852](C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20220929204748852.png)

```c++
int phi(int x)
{
    int res = x;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res = res / i * (i - 1);//如果写出res*(i-1/i) 括号里面是1-1/i 有可能是小数所以要避免
            while (x % i == 0){
            //ϕ(6)=6×(1−1/2)×(1−1/3)=6×12×23=2
                x/=i;
            }
        }
    if (x > 1) res = res / x * (x - 1);//x大于根号x 单独处理

    return res;
}
```

### 筛法求欧拉函数

首先 欧拉函数是一个 积性函数 就是说 m,n互素 则
$$
φ(mn)=φ(m)∗φ(n)
$$
如果X 是一个素数P  x=p
$$
φ(x)=x∗(1−\frac{1}{p})=p∗(\frac{p−1}{p})=p−1
$$
不是素数的时候 用最小的素因子去计算  i%p=0
$$
gcd(i,p)=pφ(i)=i∗(1−\frac{1}{p1})∗…∗(1−\frac{1}{pk})
$$

$$
因为p是i的因子所以在计算φ(i)的已经算过p了 
φ(i∗p)=p∗i∗(1−\frac{1}{p1})∗…∗(1−\frac{1}{pk}) φ(i∗p)=p∗φ(i)
$$



当 i 和 p 互质的时候 i%p!=0 gcd(i,p)=1(互质数只有1)
$$
φ(i∗p)=φ(i)∗φ(p)=φ(i)∗(p−1)
$$

- eg 筛法求欧拉函数

- ```c++
  #include<iostream>
  using namespace std;
  const int N = 1e6+10;
  int primes[N];
  int phi[N];
  bool st[N];
  int cnt;
  
  void get_eulers(int x){
      phi[1]=1;//1和1互质
      for(int i=2;i<=x;i++){
          if(!st[i]){
              primes[cnt++]=i;
              phi[i]=i-1;//欧拉函数定义：与1~i互质的个数是i-1
          }
          for(int j=0;primes[j]<=x/i;j++){//从小到大取出质数
              st[primes[j]*i]=true;
              if(i%primes[j]==0){
                  //i整除primes phi个数是phi[最小质数]的i倍数
                  phi[i*primes[j]]=phi[i]*primes[j];//phi[6]=2*phi[3]=4
                  break;
              }else{
              //i和primes[j]互质，phi[]的值要多乘以(1-1/primes[j])
                  phi[i*primes[j]]=phi[i]*(primes[j]-1);//phi[i]*primes[j]*(1-1/primes[j])
              }
          }
      }
  }
  
  
  int main(){
      int n;
      cin>>n;
      
      get_eulers(n);
      long long res=0;
      for(int i=1;i<=n;i++) res+=phi[i];
      cout<<res;
      return 0;
  }
  
  // 代码解释：
  // 质数ii的欧拉函数即为phi[i] = i - 1：1 ~ i−1i−1均与ii互质，共i−1i−1个。
  // phi[primes[j] * i]分为两种情况：
  // ① i % primes[j] == 0时：primes[j]是i的最小质因子，也是primes[j] * i的最小质因子，因此1 - 1 / primes[j]这一项在phi[i]中计算过了，只需将基数NN修正为primes[j]倍，最终结果为phi[i] * primes[j]。
  // ② i % primes[j] != 0：primes[j]不是i的质因子，只是primes[j] * i的最小质因子，因此不仅需要将基数NN修正为primes[j]倍，还需要补上1 - 1 / primes[j]这一项，因此最终结果phi[i] * (primes[j] - 1)。
  
  
  ```

  

### 快速幂 

```c++
求m^k mod p 时间复杂度O(logk)

int qmi(int a,int b,int p){
	int res=1%p;//res=1
	while(b){
		if(b&1) res=res*a%p;//如果b的第0位是1，此时×a，如果是0，说明这个位也就是2^k单位的基数是0
		a=a*a%p;//求a^2
		k>==1;//b的二进制右移一位
	}
	return res;
}

朴素做法要O(K) k是1e9复杂度过高，用二进制优化可以节省到O(30)
思路是先预处理b的二进制位，例如a^2^0、a^2^1，每次向右移动一位b的二进制，如果最右边是1，说明当前a的二次方的基数不为0，res要乘以当前a的二次方。例如2->101 枚举第2位，a^2^1这里没有基数，所以不做处理。枚举第三位，a^2^2这里是1；、所以应该乘上a^2^1、
```

#### eg:快速幂求逆元

定义:即已知 b 与 m 互质 且 b|a则求一个xx 使得 
$$
a/b≡a∗x \ mod \ m
$$
[注] 简单定义 即
$$
b∗x≡1\ mod \ m
$$
 且 b 与 m 互质 则 x 为 b 的逆元

1. 当mm为质数时
求解过程如下 ：

由费马小定理可知


$$
b^{m−1}≡1\ mod\ m
$$
而
$$
a/b≡a∗x\quad mod\ m
$$
联立以上两式，得:
$$
a/b∗b^{m-1}≡a∗x \ mod\ m
$$
即为
$$
a∗b^{m−2}≡a∗x\ mod\ m
$$
而b|a,且b与m互质,因此对于b来说,一定存在一个a也与m互质,故而a可以在两边同时约去
$$
x≡b^{m−2}\ mod\ m
$$
![image-20220930204638328](C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20220930204638328.png)

```c++
#include<iostream>
using namespace std;
typedef long long ll;

ll qmi(int a,int b,int p){
    ll res=1;//定义成longlong 否则数值越界
    while(b){
        if(b&1) res=res*a%p;
        b>>=1;
        a=a*(ll)a%p;
    }
    return res;
}

int main(){
    int n,a,p;
    scanf("%d",&n);//读入用scanf读快
    while(n--){
        cin>>a>>p;
        if(a%p) cout<<qmi(a,p-2,p)<<endl;//x=a^p-2 mod p 公式
        else cout<<"impossible"<<endl;
    }
    return 0;
}
```

### 拓展欧几里得算法

![QQ图片20210501202408.jpg](https://cdn.acwing.com/media/article/image/2021/05/01/65682_7cbaa38faa-QQ%E5%9B%BE%E7%89%8720210501202408.jpg)

![image-20221004104120104](C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20221004104120104.png)

```c++
//求x，y，使得ax+by=gcd(a,b)
int exgcd(int a,int b,int &x,int &y){
	if(!b){
		x=1,y=0;
		return a;
	}
	int d=exgcd(b,a%b,y,x);
	y-=a/b*x;
	return d;
}
```

```c++
#include<iostream>
using namespace std;

void exgcd(int a,int b,int &x,int &y){//递归是解决了一个子问题，
//也就是递归之后 b * y + (a % b) * x = d，但你需要求的是 a * x + b * y = d中的系数
    if(!b){
        x=1,y=0;
        return ;
    }
    //一直递归到最后一层，此时每层返回x和y的值，上一层再用返回的xy求当前层的特解
    // int d=exgcd(b,a%b,x,y);//不交换y，x 稍微麻烦
    // int t=y;//中间变量存y值
    // y=x-(a/b)*y;
    // x=t;
    exgcd(b,a%b,y,x);//交换x，y x不变 都满足gcd(a,b)的公约数
    y-=a/b*x;
    return ;
}

int main(){
    int n;
    scanf("%d",&n);
    while(n--){
        int a,b;
        cin>>a>>b;
        int x,y;
        exgcd(a,b,x,y);
        cout<<x<<' '<<y<<endl;
    }
    return 0;
}
```

### 拓展中国剩余定理

（模数之间两两不互质，互质是中国剩余定理）

![image-20221005172438948](C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20221005172438948.png)



//拓展版

![image-20221005172455428](C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20221005172455428.png)

eg：表达整数的奇怪方式

```c++
#include<iostream>
using namespace std;
typedef long long ll;

ll exgcd(ll a, ll b,ll &x,ll &y){
    if(!b){
        x=1,y=0;
        return a;
    }
    int d=exgcd(b,a%b,y,x);
    y-=a/b*x;
    return d;
}

int main(){
    int n;
    ll a1,m1;
    cin>>n>>a1>>m1;//a1 m1写在外面下一次循环会更新
    ll x=0;
    
    for(int i=1;i<n;i++){
        ll a2,m2;
        cin>>a2>>m2;
        ll k1,k2;
        ll d=exgcd(a1,a2,k1,k2);//为了求k1a1-k2a2=d
        if((m2-m1)%d){//不满足被整除关系，说明没有整数解
            x=-1;
            break;
        }
        k1*=(m2-m1)/d;//k1此时是k1a1-k2a2=d的解，d变成m2-m1 k值要放大(m2-m1)/d
        ll t=abs(a2/d);//t存a2/d,后面%t是为了防止数值过大溢出 a范围大于1可以不用abs
        k1=(k1%t+t)%t;//通解k1=k1+k*a2/d 为了使k1%t不为负数而且变成最小正整数
        
        // 先更新m1，用的a还是前k-1的a；再更新a变成前k的。两行不可颠倒
        m1=k1*a1+m1;//新式x=k1a1+m1+a2*a1/d*k m为k1a1+m1 m1被赋值为当前m的值
        a1=abs(a1*a2/d);//a1为a2*a1/d*k
        //循环结束时a1的值为当前所有的a1,a2,……an中的最小公倍数
        
    }
    if(x!=-1){
        x=(m1%a1+a1)%a1;//退出循环后 与当前最小公倍数取模求出最小正整数解
    }
    cout<<x<<endl;
    return 0;
}
```

- 小哲思路：通过公式推导，可以发现每两个式子可以合并成一个新式子(x=k1a1+m1+a2 * a1/d * k  其中吧 k1a1+m1看成m 把a2 * a1/d看成新a  新式就等价于x=m+ka 这与合并前的式子相同)。因此n个式子合并n-1次会变成一个式子,最后的x即满足答案

```c++
//大佬思路

思路：
合并：将第一条和第二条合并，再合并进第三条……一直合并n-1次，就只剩一条了。
具体实现：1.由题意得x % a1 = m1 , x % a2 = m2,
2.即x = k1a1 + m1 , x = k2a2+m2,
3.取出两式等号右边得：k1a1 + m1 = k2a2+m2
4.移项得:k1a1-k2a2 = m2-m1.( * )
5.接下来利用扩展欧几里得算法求得k1的解和最大公约数d，判断d是否能整除m2-m1，若不行说明无解，否则继续
6.再将k1自乘上一个(m2-m1)/d才是( * )的一个解，可以知道k1的通解是k1+ka2/d，k2的通解是k2+ka1/d
7.为了防止数据溢出，我们需要求得k1的最小正整数解，在c++中，取模会得到负值，因此我们需要以下操作
8.令t=a2/d，k1 = (k1 % t + t) % t
9.将k1= k1+ka2/d，代回x = k1a1 + m1中得：x = k1a1+m1+ka1a2/d
10.发现此时x的表达式和原来的很像，一部分常量，一部分变量，所以我们重新赋值 , m1 = k1a1+m1，a1= abs(a1 / d * a2)
11.这样一来原来的两条式子就合并为一条x=ka1+m1（此时a1和m1已经变了），继续合并即可。
12.最后出的m1就是解，因为在10中可以发现m1=k1a1+m1就是x的值，不过在输出也要对其a1取模以输出最小的非负整数解。
```

### 高斯消元解线性方程

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210529160107305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JldHRsZV9raW5n,size_16,color_FFFFFF,t_70)

```c++
#include<bits/stdc++.h>
using namespace std;

int gauss(){
	int c,r;//c:cols r:rows
	
	for(c=0,r=0;c<n;c++){//列比行多1 最后一列是结果 循环行数就可以把矩阵化为三角形式 
		int t=r;//临时存储行，找到绝对值最大的
        //什么要找绝对值最大的那一行，一是因为可以寻找一个非零行，二是作浮点数除法时，显然除以一个大数会让精度更好，误差更小
		for(int i=r;i<n;i++){
			if(fabs(a[i][c])>fabs(a[t][c])){
				t=i;//如果i行c列大于t行c列 更新当前列的行值 
			}
		}
		
		if(fabs(a[t][c])<eps) continue;//如果当前列的最大值是0，说明一整列都是0,退出for循环 列++扫下一列 
		for(int i=c;i<=n;i++) swap(a[t][i],a[r][i]);//把当前行换到最上面(for开始的行) **易错点交换位置列要写成i而不是c**
		for(int i=n;i>=c;i--) a[r][i]/=a[r][c];//让当前行的第一列变成1，其他列除以对应的数，需要从后往前推
		for(int i=r+1;i<n;i++){//当前行下面的列全部清零 
			if(fabs(a[i][c])>eps){
				for(int j=n;j>=c;j--){//倒着清空，防止前面值被更新影响后面 
				/*1 2 3 4 
				  2 5 7 9
				
				第二行为了让第一列清为0，需要减去1*2也就是上一行对应的值乘以当前行的c列为了清空需要设定的倍数(2)
				所以a[r+1][j]-=a[r][j]*a[r+1][c] 
				*/
					a[i][j]-=a[r][j]*a[i][c];//因为上一行的列是1，所以a[i][c]是1的几倍，下面行数c列清零就要让一整行减去对应上一行的倍数 
				}
			}
		}
		r++;//下一行开始 
	}
	if(r<n){//上面for循环退出后到这里 说明对角线有0 
	//0*x1+0*x2+...0*xi+...0*xn=a(a!=0)无解
	// 0*x1+0*x2+...0*xi+...0*xn=a(a==0)无穷解 
		for(int i=r;i<n;i++){//r+1到n 系数全为0 再去判断结果列看a等于0还是不等于0 
			if(fabs(a[i][n])>eps){
				return 2;//最后一列不为0 但是它左边全是0说明无解 
			}
		}
		return 1;//无穷解 
	}
	
	
//	1 2 3 4
//	0 1 3 1
//	0 0 1 3
	for(int i=n-1;i>=0;i--){ 
		for(int j=i+1;j<n;j++){//只要保留第i行第i列的系数即可,所以从第i+1行开始一直消到第n行 
			a[i][n]-=a[i][j]*a[j][n];//第二行为了消除非主元，最后一列1-3*3=-8 
		}
	}
	return 0;//唯一解 
} 
```

### 组合数

#### 递推法

```c++
//c[a][b]表示从a个苹果中选b个的方案数
for(int i=0;i<N;i++){
	for(int j=0;j<=i;j++){
		if(!j) c[i][j]=1;//一个都不取是一种方案
		else c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;//a堆中取b或者不取b两种情况
	}
}
```

#### 预处理逆元

```c++
首先预处理出所有阶乘取模的余数fact[N],以及所有阶乘取模的逆元infact[N]
如果取模的数是质数，可以用费马小定理求逆元
int qmi(int a,int k,int p)//快速幂模板
{
	int res=1;
	while(k){
		if(k&1) res=(ll)res*a%p;
		a=(ll)a*a%p;
		k>>=1;
	}
	return res;
}

//预处理阶乘的余数和阶乘逆元的余数
fact[0]=infact[0]=1;
for(int i=1;i<N;i++){//不能等于n 数组溢出
	fact[i]=(ll)fact[i-1]*i%mod;
	infact[i]=(ll)infact[i-1]*qmi(i,mod-2,mod)%mod;
    //或者infact[i]=qmi(fact[i],mod-2,mod)%mod;
}
```

#### Lucas定理

```c++
//若p是质数，则对于任意整数1<=m<=n,有
//C(n,m)=C(n%p,m%p)*C(n/p,m/p)(mod p)

int qmi(int a,int k,int p){
    int res=1%p;
    while(k){
        if(k&1) res=(ll)res*a%p;
        a=(ll)a*a%p;
        k>>=1;
    }
    return res;
}

int C(int a,int b,int p)//通过定理求组合数
{
    if(a<b) return 0;
    
    ll x=1,y=1;//x是分子，y是分母
    for(int i=a,j=1;j<=b;i--,j++){//x=a*(a-1)*...*(a-b+1) 也就是a!/(a-b)!
        x=(ll)x*i%p;
        y=(ll)y*j%p;
    }
    return x*(ll)qmi(y,p-2,p)%p;//上面x的结果乘以b！的逆元
}

int lucas(ll a,ll b,int p)
{//lucas是利用C来生成函数,满足下一个系数a/p>p（a>p），就取余继续递归，否则返回
    if(a<p && b<p) return C(a,b,p);//a和b小于p,也就是说ak=a/p等于0，此时ak不存在，返回到最大系数是ak-1
    return (ll)C(a%p,b%p,p)*lucas(a/p,b/p,p)%p;//a%p后肯定是<p的,所以可以用C(),但a/p后不一定<p 所以用lucas继续递归
}


```

#### 分解质因数法

```c++
/*
当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用
	1.筛法求出范围内的所有质数
	2.通过c(a,b)=a!/b!/(a-b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ... eg 12=6+3+1=10
	3.用高精度乘法将所有质因数相乘
*/

int primes[N],cnt;//存储所有质数
int sum[N];//存储每个质数的次数
bool st[N];//存储每个质数是否已被筛掉

void get_primes(int n){
    for(int i=2;i<=n;i++){
        if(!st[i]) primes[cnt++]=i;
        for(int j=0;primes[j]<=n/i;j++){
            st[primes[j]*i]=true;
            if(i%primes[j]==0) break;//如果扫到边界或者合数 要记得退出
        }
    }
}

int get(int n,int p){
	int res=0;
	while(n){
		res+=n/p;//累加得到当前素因数p的个数 12中2有十个，12/2+12/2^2+12/2^3
		n/=p;
	}
	return res;
}

//高精度乘法
vector<int> mul(vector<int> a,int b){
	vector<int> c;
	int t=0;
	for(int i=0;i<a.size();i++){
		t+=a[i]*b;
		c.push_back(t%10);
		t/=10;
	}
	while(t){//a的最大位数是两位数或更高位 
		c.push_back(t%10);
		t/=10;
	}
	return c;
} 

get_primes(a);//预处理范围内所有质数 a>b

	for(int i=0;i<cnt;i++){
		int p=primes[i];
		sum[i]=get(a,p)-get(a-b,p)-get(b,p);//记录组合数中各个素因数个数 
	}
	
	vector<int> res;
	res.push_back(1);//初始值赋予1
	
	/*
	12 的素因数是 2、3、5、7、11 
	*/
	for(int i=0;i<cnt;i++){//素因数的个数 
		for(int j=0;j<sum[i];j++){//当前素因数的个数 
			res=mul(res,primes[i]);//2^10*……以此类推 
		}
	} 
```

### 卡特兰数

```c++
给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为： Cat(n) = C(2n, n) / (n + 1)
```

## 

